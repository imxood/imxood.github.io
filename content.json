[{"title":"","date":"2017-03-30T05:07:01.424Z","path":"2017/03/30/vs2015环境编译openssl/","text":"title:vs2015环境编译libcurl date:2017/03/301, 1&gt; 需要下载的文件: curl-7.53.1.zip, openssl-1.0.2j.tar.gz 2&gt; VS2015IDE, NASM汇编器 2, 使用汇编器NASM编译OpenSSL库: 解压openssl-1.0.2j.tar.gz到D:\\Develop\\, cd D:\\Develop\\openssl-1.0.2j,我需要的是静态库,执行下面三条命令: perl Configure VC-WIN32 –prefix=openssl_lib nmake -f ms\\nt.mak nmake -f ms\\nt.mak install 大概等待十分钟,在当前目录下会生成所需要的openssl_lib文件夹 3, 编译libcurl 解压curl-7.53.1.zip到D:\\Develop, cd D:\\Develop\\curl-7.53.1\\winbuild, 查看帮助: nmake /f Makefile.vc, 开始编译: nmake /f Makefile.vc mode=static VC=14 WITH_DEVEL=D:\\Develop\\openssl-1.0.2j\\openssl_lib WITH_SSL=static ENABLE_SSPI=no ENABLE_IPV6=no 命令注释 mode=dll 编译libcurl位动态链接库，如果static 就是把libcurl编译位静态库 VC=10 代表使用的是VC2010 WITH_DEVEL=C:\\openssl_lib 表示用到第三方开发包的目录，本例上面已经将openssl编译好的开发包，安装到此目录 WITH_SSL=static ,代表使用libssl库 是静态库 ENABLE_SSPI=no ENABLE_IPV6=no（禁用SSPI，ipV6功能） 稍等片刻就编译成功了。 不过,上面的编译是没有问题的,运行的时候会有问题: 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_cleanup 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_getinfo 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_setopt 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_slist_append 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_init 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_global_init 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_perform 解决办法是: 加入预编译选项：项目-&gt;属性-&gt;c/c++ -&gt;预处理器-&gt;预处理器，添加一条:BUILDING_LIBCURL 总结自: http://www.cnblogs.com/openiris/p/3812443.html http://blog.csdn.net/varding/article/details/5329023 学习是一种乐趣.","tags":[]},{"title":"信号","date":"2017-03-25T16:00:00.000Z","path":"2017/03/26/信号/","text":"什么是信号?信号就是软中断 什么是软中断?软中断就是软件模拟的中断 什么是中断中断服务程序 信号是进程的异步通信机制. 系统提供的信号如何查看kill -l 一般来说,信号有64个信号kill -信号编号 pid 信号产生,信号阻塞,信号未决,进程对信号的捕获,信号处理程序 进程对信号的默认处理动作是终止进程用户可以根据自己的需求设置进程对信号的处理SIG_DFL 缺省SIG_IGN 忽略用户自定义信号处理函数 需要向进程注册一个函数,当信号到来的时候,使用这个注册的信号处理函数来处理信号到达. 使用signal(2)注册信号处理函数","tags":[]},{"title":"Linux 程序与进程","date":"2017-03-23T16:00:00.000Z","path":"2017/03/24/Linux 程序与进程/","text":"程序是完成特定任务的一系列指令集合 从用户的角度来看进程是程序的一次动态执行过程从操作系统的核心来看，进程是操作系统分配的内存、CPU时间片等资源的基本单位。进程是资源分配的最小单位每一个进程都有自己独立的地址空间与执行状态。 进程结构 进程的静态描述：由三部分组成:PCB、有关程序段和相关数据结构集。 进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。 多进程间的关系,fork? 在进程空间里加载新的映像exec","tags":[]},{"title":"X86汇编 转移指令","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/X86汇编 转移指令/","text":"操作符offset: 取得标号的偏移地址 1234start: mov ax,offset start ;相当于mov ax,0s: mov ax,offset s ;相当于mov ax,3 “jmp short 标号”: 转到标号处执行指令(段内短转移),(IP)=(IP)+8位位移 “jmp near ptr 标号”: 转到标号处执行指令(段内短转移),(IP)=(IP)+16位位移 “jmp far ptr 标号”: 段间转移(源转移) (CS)=标号所在段的段地址, (IP)=标号在段中的偏移地址 far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP “jmp 16位reg”: (IP)= (16位reg) “jmp word ptr 内存单元地址(段内转移)”: 从内存单元地址处存放着一个字,是转移的目的偏移地址 123mov ax,0123hmov ds:[0],axjmp word ptr ds:[0] ;执行后 “jmp dword ptr 内存单元地址(段间转移)”: 高地址处的字是目的段地址,低地址处的字是目的偏移地址 (CS)=(内存单元地址+2) (IP)=(内存单元地址)","tags":[]},{"title":"进程","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/进程/","text":"一, 进程映射 代码段: 字符串,常量数据段: 全局变量,静态局部变量堆: 使用malloc等一系列函数向系统申请的内存空间在堆里栈: 自动局部变量和形参 注意变量的生命周期和作用域 二, 使用mmap将物理地址映射到进程的虚拟地址空间 处理这个映射,需要使用mmap和munmap 123456789#include &lt;sys/mman.h&gt;//功能: 映射文件或设备到内存空间(虚拟地址空间)//返回值: 若错误,返回MAP_FAILED, errno被设置, 若成功,返回映射区域的地址void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); //功能: 解除内存映射//返回值: 0 成功, 1 失败int munmap(void *addr, size_t length);","tags":[]},{"title":"Linux c文件操作","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/Linux c文件操作/","text":"open(2),close(2),read(2),write(2),lseek(2) 1234//打开文件int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);//返回值:-1,错误,重置errno O_EXCL: 与O_CREAT一起指定.文件存在报错 O_CREATE: 如果文件不存在,则创建文件,需要提供文件的权限.权限的有效性是提供的权限和umask的运算结果 若是新的文件,则可以设置权限mode,文件最终的权限计算规则是:mode &amp; ~umask, mask是权限掩码(默认不要的权限) O_TRUNC: 文件存在就清空 补充:-rw-r–r– 1 root root 517 2月 24 21:09 02_25.cpp第一个字符决定了文件的类型: ‘-‘表示普通文件,’d’表示目录文件,’b’块设备文件,’c’字符设备文件,’s’socket文件,l软链接文件,p管道文件 //打开文件,若存在,报错 open(argv[1], O_RDWR | O_CREAT | O_EXCL, 0664); umask:777==&gt;111 111 111 110 100 100 touch test.txt———- 1 root root 367 3月 17 05:39 test_dynamic.c权限:0000 110 100 100umask:022==&gt;000 010 010 111 101 101-rw-r–r– 1 root root 0 3月 21 03:09 c权限: 文件描述符中:STDIN_","tags":[]},{"title":"mmap函数引起的分析","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/mmap函数引起的分析/","text":"http://www.cnblogs.com/huxiao-tee/p/4660352.html http://blog.csdn.net/lixungogogo/article/details/52210750","tags":[]},{"title":"Unix C程序中的错误处理","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/Unix C的一般处理/","text":"一, Unix C程序中的错误处理 系统提供了一个全局变量 errno 如何根据错误编号获取错误信息? perror函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;void perror(const char *s);//man 3 perror//功能:打印一个系统错误信息//参数:s 自定义的提示//例子:#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], &quot;r&quot;); if(fp==NULL)&#123;//发生错误时 perror(&quot;fopen&quot;);//输出错误信息到显示器 return 1; &#125; printf(&quot;open file success!\\n&quot;); fclose(fp); return 0;&#125;//shell终端:root@kali:~/maxu# gcc test.c &amp;&amp; ./a.out abc.hello//显示:fopen: No such file or directory#include &lt;string.h&gt;char *strerror(int errnum);//man 3 strerror//功能:根据errnum,返回描述errnum的错误信息,如果errnum找不到,返回&quot;Unknown &quot;//参数:errnum 错误编号//例子:#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//这个头文件中存在声明:int errno;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], &quot;r&quot;); if(fp==NULL)&#123;//发生错误时 printf(&quot;errno: %d\\n&quot;, errno); printf(&quot;%s\\n&quot;, strerror(errno)); return 1; &#125; printf(&quot;open file success...\\n&quot;); fclose(fp); return 0;&#125;//shell:root@kali:~/maxu# ./a.out a//输出:errno: 2No such file or directory 补充:标准输入 键盘 0标准输出 显示器 1标准错误输出 显示器 2 帮助的使用:man 1 命令man 2 系统调用函数的名字man 3 库函数的名称 三, 进程映射","tags":[]},{"title":"GDB调试器的使用","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/GDB调试器的使用/","text":"第一步: 在编译链接源文件成可执行文件的时候,加参数: -g, 生成的可执行文件带有调试信息 1root@kali:~/maxu/test_lib# gcc -g *.c -o tt 第二步: 使用gdb调试工具,调试带有调试信息的可执行文件1root@kali:~/maxu/test_lib# gdb tt 第三步: 执行相关调试指令 l 列出程序代码(list) b 5 为第5行设置断点(break) r 运行可执行程序(运行到下一个断点前,比如上面的第五行,未执行第五行)(run) p a 显示a变量的值(print) n 执行下一条语句(next) s 按步执行语句,有函数就进入函数内(step) q 离开gdb(quit)","tags":[]},{"title":"gcc简单教程","date":"2017-03-18T16:00:00.000Z","path":"2017/03/19/gcc简单教程/","text":"GCC(GNU Compiler Collection)是Linux下最常用的C语言编译器，是GNU项目中符合ANSI C标准的编译系统,能够编译用C、C++和Object C等语言编写的程序。同时它可以通过不同的前端模块来支持各种语言，如Java、Fortran、Pascal、Modula-3和Ada等。 一. CC编译程序有四个阶段 预处理（Pre-Processing）编译（Compiling）汇编（Assembling）链接（Linking） 1.1 预处理 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容1gcc -E test.c 或 gcc -E test.c -o test.i -E进行预处理后结束-o用于指定输出(out)文件名 1.2 编译为汇编代码 编译过程完成后，将生成程序的汇编代码test.s1gcc -S test.i -o test.s 1.3 汇编 这一步会为每一个源文件产生一个目标文件1gcc -c test.c –o test.o 1.4 链接1gcc -c test.c –o test.o 二. 静态库的制作与使用1,将相关源文件编译为目标文件gcc -c *.c 2,将目标文件添加到静态库中ar -r libmymath.a *.o 3,使用静态库链接目标文件形成可执行程序gcc test.o -Ltest_lib -lmymath test.o是main函数所在的文件,L是链接文件的路径,l是链接库的名字 三. 动态库的制作与使用动态库的命名: lib+库名.so1,将相关源文件编译为与位置无关的目标文件gcc -c -fPIC *c 2,将目标文件添加到动态库中 gcc -shared -o libmymath.so *.o 3,将动态库链接到目标文件中gcc test.c -Ltest_lib -lmymath -o tt -std=c99 ./tt: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory ldd tt//使用ldd命令查看可执行依赖的动态库文件告诉加载器动态库文件的路径,两种方式:使用环境变量LD_LIBRARY_PATH指定加载器的寻找路径.LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./test_lib 四. 动态加载动态库函数按需加载动态库中的一个或多个函数.需要使用系统提供的以下函数: void dlopen(const char filename, int flags); Link with -ldl: 编译时需要加上 补充: nm命令的使用 nm 二进制文件名 $ nm add.o 00000000 T t_add 0000000e T t_sub T 代表了add.o文件中包含了t_add和t_sub函数的实现代码。 $ nm test.o 00000000 T main U printf U t_add U t_div U t_mul U t_sub U 代表了在该文件中使用到了这个函数，但是没有这个函数的实现代码。 链接的过程，就是多个文件拼接成一个可执行文件的过程。 目前的链接过程是发生在编译的时候，这个链接称为静态链接。 动态链接是在代码加载到内存执行的时候发生的。","tags":[]},{"title":"使用Hexo+Github部署个人博客","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/使用Hexo+Github部署个人博客/","text":"​ 选一个好一点的用户名来注册一个github帐号,这个用户名会成为你的静态网站的域名的一部分(userName.github.io),开通个人静态站点 安装git,nodejs,安装完毕后,打开git-gui(就是因为git-gui好看点,也打开cmd), 12345cd /e/Platform/Gitnpm install -g hexo-clihexo init blogcd blognpm install 执行完后,你的目录是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 然后,执行 1234hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这时,在浏览器中打开 http://localhost:4000 ,就可以访问你的本地站点了","tags":[]},{"title":"vim使用技巧","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/vim使用技巧/","text":"1,查找指定字符: /第一个出现的字符串 ?最后一个出现的字符串 eg: :/abc :?abc","tags":[]},{"title":"学习使用汇编的调试工具debug","date":"2017-03-14T16:00:00.000Z","path":"2017/03/15/学习使用汇编的调试工具debug/","text":"R命令查看、改变CPU寄存器内容； D命令查看内存中的内容； D [段地址:偏移地址] E命令修改内存中的内容； E 段地址:起始偏移地址 数据1 数据2……… U命令将内存中机器指令翻译成汇编指令； 显示三个部分的内容: 左边为内存地址，其次为机器码 最右边机器码对应的汇编指令。 T命令执行一条机器指令； A命令以汇编指令的格式在内存中写入一条机器指令；","tags":[]},{"title":"linux启动ssh","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/linux启动ssh/","text":"sudo apt-get install openssh-server 安装ssh ps -e |grep ssh 查看是否已启动 systemctl is-enabled ssh 判断ssh是否是开机启动 systemctl enable ssh 设置ssh开机启动 systemctl status ssh 查看ssh状态 1),如果报错:algorithm negotiation failed 解决方法:添加下面的内容到/etc/ssh/sshd_config末尾(3行): Ciphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbc MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96 KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org 2),使用root帐号,密码是对的,但是Permission denied,可能是因为: 默认禁用root帐号,修改/etc/ssh/sshd_config文件,设置PermitRootLogin: PermitRootLogin yes","tags":[]}]