[{"title":"","date":"2017-03-20T02:10:06.168Z","path":"2017/03/20/GDB调试器的使用/","text":"GDB调试器的使用第一步: 在编译链接源文件成可执行文件的时候,加参数: -g, 生成的可执行文件带有调试信息 1root@kali:~/maxu/test_lib# gcc -g *.c -o tt 第二步: 使用gdb调试工具,调试带有调试信息的可执行文件1root@kali:~/maxu/test_lib# gdb tt 第三步: 执行相关调试指令 l 列出程序代码(list) b 5 为第5行设置断点(break) r 运行可执行程序(运行到下一个断点前,比如上面的第五行,未执行第五行)(run) p a 显示a变量的值(print) n 执行下一条语句(next) s 按步执行语句,有函数就进入函数内(step) q 离开gdb(quit)","tags":[]},{"title":"","date":"2017-03-20T01:20:33.481Z","path":"2017/03/20/Unix C的一般处理/","text":"Unix C程序中的错误处理一, Unix C程序中的错误处理 系统提供了一个全局变量 errno 如何根据错误编号获取错误信息? perror函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;void perror(const char *s);//man 3 perror//功能:打印一个系统错误信息//参数:s 自定义的提示//例子:#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], \"r\"); if(fp==NULL)&#123;//发生错误时 perror(\"fopen\");//输出错误信息到显示器 return 1; &#125; printf(\"open file success!\\n\"); fclose(fp); return 0;&#125;//shell终端:root@kali:~/maxu# gcc test.c &amp;&amp; ./a.out abc.hello//显示:fopen: No such file or directory#include &lt;string.h&gt;char *strerror(int errnum);//man 3 strerror//功能:根据errnum,返回描述errnum的错误信息,如果errnum找不到,返回\"Unknown \"//参数:errnum 错误编号//例子:#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//这个头文件中存在声明:int errno;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], \"r\"); if(fp==NULL)&#123;//发生错误时 printf(\"errno: %d\\n\", errno); printf(\"%s\\n\", strerror(errno)); return 1; &#125; printf(\"open file success...\\n\"); fclose(fp); return 0;&#125;//shell:root@kali:~/maxu# ./a.out a//输出:errno: 2No such file or directory 补充:stdio 标准输入 键盘stdout 标准输出 显示器stderr 标准错误输出 显示器 帮助的使用:man 1 命令man 2 系统调用函数的名字man 3 库函数的名称 三, 进程映射","tags":[]},{"title":"","date":"2017-03-17T01:20:28.976Z","path":"2017/03/17/C语言学习/","text":"gcc简单教程GCC(GNU Compiler Collection)是Linux下最常用的C语言编译器，是GNU项目中符合ANSI C标准的编译系统,能够编译用C、C++和Object C等语言编写的程序。同时它可以通过不同的前端模块来支持各种语言，如Java、Fortran、Pascal、Modula-3和Ada等。 一. CC编译程序有四个阶段 预处理（Pre-Processing）编译（Compiling）汇编（Assembling）链接（Linking） 1.1 预处理 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容1gcc -E test.c 或 gcc -E test.c -o test.i -E进行预处理后结束-o用于指定输出(out)文件名 1.2 编译为汇编代码 编译过程完成后，将生成程序的汇编代码test.s1gcc -S test.i -o test.s 1.3 汇编 这一步会为每一个源文件产生一个目标文件1gcc -c test.c –o test.o 1.4 链接1gcc -c test.c –o test.o 二. 静态库的制作与使用1,将相关源文件编译为目标文件gcc -c *.c 2,将目标文件添加到静态库中ar -r libmymath.a *.o 3,使用静态库链接目标文件形成可执行程序gcc test.o -Ltest_lib -lmymath test.o是main函数所在的文件,L是链接文件的路径,l是链接库的名字 三. 动态库的制作与使用动态库的命名: lib+库名.so1,将相关源文件编译为与位置无关的目标文件gcc -c -fPIC *c 2,将目标文件添加到动态库中 gcc -shared -o libmymath.so *.o 3,将动态库链接到目标文件中gcc test.c -Ltest_lib -lmymath -o tt -std=c99 ./tt: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory ldd tt//使用ldd命令查看可执行依赖的动态库文件告诉加载器动态库文件的路径,两种方式:使用环境变量LD_LIBRARY_PATH指定加载器的寻找路径.LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./test_lib 四. 动态加载动态库函数按需加载动态库中的一个或多个函数.需要使用系统提供的以下函数: void dlopen(const char filename, int flags); Link with -ldl: 编译时需要加上","tags":[]},{"title":"使用Hexo+Github部署个人博客","date":"2017-03-16T11:37:56.493Z","path":"2017/03/16/使用Hexo+Github部署个人博客/","text":"​ 选一个好一点的用户名来注册一个github帐号,这个用户名会成为你的静态网站的域名的一部分(userName.github.io),开通个人静态站点 安装git,nodejs,安装完毕后,打开git-gui(就是因为git-gui好看点,也打开cmd), 12345cd /e/Platform/Gitnpm install -g hexo-clihexo init blogcd blognpm install 执行完后,你的目录是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 然后,执行 1234hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这时,在浏览器中打开 http://localhost:4000 ,就可以访问你的本地站点了","tags":[]},{"title":"Test","date":"2017-03-16T09:23:09.000Z","path":"2017/03/16/Test/","text":"","tags":[]},{"title":"Hello World","date":"2017-03-16T08:17:40.459Z","path":"2017/03/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]