[{"title":"","date":"2017-05-08T02:39:41.266Z","path":"2017/05/08/函数调用堆栈分析/","text":"函数调用堆栈分析 代码: #include int f1(){ int temp = 3; printf(“&amp;temp:%p”, &amp;temp); printf(“ temp:%d”, temp); return temp;}int main (void) { int a = f1(); printf(&quot;&amp;a:%p&quot;, &amp;a); printf(&quot; a:%d&quot;, a); return 0; } 下面我们来分析函数调用的堆栈: 分析前要了解下什么是ebp,ebp是函数的栈底,也就是刚进入函数时的栈地址,当进入一个函数时,会执行push ebp ;保存前一个函数的ebp,便于当前函数执行完,恢复前一个函数的栈mov ebp,esp; ;设置当前函数的ebp C语言中的定义变量,在汇编中的表现形式是栈顶esp的移动:比如:int a; –&gt; sub esp,4赋值:a=1; –&gt; mov dword ptr [ebp-4],1使用因为esp是随时改变的,所以通过栈底ebp-NUM的形式去访问地址 先看看主函数:11: int main (void) {00406F70 push ebp ;00406F71 mov ebp,esp00406F73 sub esp,44h00406F76 push ebx00406F77 push esi00406F78 push edi00406F79 lea edi,[ebp-44h]00406F7C mov ecx,11h00406F81 mov eax,0CCCCCCCCh00406F86 rep stos dword ptr [edi]12:13: int a = f1();00406F88 call @ILT+585(_f1) (0040124e)00406F8D mov dword ptr [ebp-4],eax14:15: printf(“&amp;a:%p”, &amp;a);00406F90 lea eax,[ebp-4]00406F93 push eax00406F94 push offset string “&amp;a:%p” (0046f094)00406F99 call printf (00422050)00406F9E add esp,816: printf(“ a:%d”, a);00406FA1 mov ecx,dword ptr [ebp-4]00406FA4 push ecx00406FA5 push offset string “ a:%d” (0046f08c)00406FAA call printf (00422050)00406FAF add esp,817:18: return 0;00406FB2 xor eax,eax19: }00406FB4 pop edi00406FB5 pop esi00406FB6 pop ebx00406FB7 add esp,44h00406FBA cmp ebp,esp00406FBC call __chkesp (00420c60)00406FC1 mov esp,ebp00406FC3 pop ebp00406FC4 ret 下面分析:00406F73~00406F86:保存寄存器的状态, 再是调用函数:1: #include 2:3: int f1(){00406F00 push ebp00406F01 mov ebp,esp00406F03 sub esp,44h00406F06 push ebx00406F07 push esi00406F08 push edi00406F09 lea edi,[ebp-44h]00406F0C mov ecx,11h00406F11 mov eax,0CCCCCCCCh00406F16 rep stos dword ptr [edi]4: int temp = 3;00406F18 mov dword ptr [ebp-4],35: printf(“&amp;temp:%p”, &amp;temp);00406F1F lea eax,[ebp-4]00406F22 push eax00406F23 push offset string “&amp;temp:%p” (0046f080)00406F28 call printf (00422050)00406F2D add esp,86: printf(“ temp:%d”, temp);00406F30 mov ecx,dword ptr [ebp-4]00406F33 push ecx00406F34 push offset string “ temp:%d” (0046f074)00406F39 call printf (00422050)00406F3E add esp,87: return temp;00406F41 mov eax,dword ptr [ebp-4]8: }00406F44 pop edi00406F45 pop esi00406F46 pop ebx00406F47 add esp,44h00406F4A cmp ebp,esp00406F4C call __chkesp (00420c60)00406F51 mov esp,ebp00406F53 pop ebp00406F54 ret 这中间有个chkesp的调用: chkesp:00420C60 jne chkesp+3 (00420c63)00420C62 ret00420C63 push ebp00420C64 mov ebp,esp00420C66 sub esp,000420C69 push eax00420C6A push edx00420C6B push ebx00420C6C push esi00420C6D push edi00420C6E push offset string “The value of ESP was not properl”… (0046f870)00420C73 push offset string “” (0046f19c)00420C78 push 2Ah00420C7A push offset string “i386\\chkesp.c” (0046f860)00420C7F push 100420C81 call _CrtDbgReport (00426550)00420C86 add esp,14h00420C89 cmp eax,100420C8C jne chkesp+2Fh (00420c8f)00420C8E int 300420C8F pop edi00420C90 pop esi00420C91 pop ebx00420C92 pop edx00420C93 pop eax00420C94 mov esp,ebp00420C96 pop ebp00420C97 ret","tags":[]},{"title":"Kali 201602编译linux0.11","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/Kali 201602编译linux0.11/","text":"卸载默认的gcc: apt autoremove gcc 安装gcc4.4: 换源,在sources.list文件中,先注释掉原来的源,添加ubuntu12.04的源, apt-get clean &amp; apt-get update, apt-get install gcc-4.4 安装好了以后,发现gcc -v命令无效,于是,cd /usr/bin,看了下,存在gcc-4.4,执行gcc-4.4 -v,发现gcc4.4安装成功了, 于是设置软连接:ln -s /usr/bin/gcc-4.4 /usr/bin/gcc 再使用:gcc -v,就一切正常了 git clone https://github.com/imxood/linux-0.11.git cd linux-0.11 make,报一下错误: 123456789101112131415gcc -I./include -traditional -c boot/head.sboot/head.s: Assembler messages:boot/head.s:45: 错误：unsupported instruction `mov&apos;boot/head.s:49: 错误：unsupported instruction `mov&apos;boot/head.s:61: 错误：unsupported instruction `mov&apos;boot/head.s:63: 错误：unsupported instruction `mov&apos;boot/head.s:138: 错误：invalid instruction suffix for `push&apos;boot/head.s:139: 错误：invalid instruction suffix for `push&apos;boot/head.s:140: 错误：invalid instruction suffix for `push&apos;boot/head.s:141: 错误：invalid instruction suffix for `push&apos;boot/head.s:142: 错误：invalid instruction suffix for `push&apos;boot/head.s:153: 错误：invalid instruction suffix for `push&apos;boot/head.s:154: 错误：invalid instruction suffix for `push&apos;boot/head.s:155: 错误：invalid instruction suffix for `push&apos;... 在head.s中,.text上一行添加一行:.code32 make 报错: eprecated. Use `-mtune=&apos; or &apos;-march=&apos; instead. init/main.c:1: error: CPU you selected does not support x86-64 instruction set 替换linux-0.11文件夹下所有的mcpu为march,共8个 make 报错: CPU you selected does not support x86-64 instruction set 在项目根路径下的Makefile中添加-m32, CC =gcc -m32 ... include/unistd.h:207: warning: function return types not compatible due to ‘volatile’ 解决方法: 修改 init/main.c 文件 将 static inline _syscall0(int,fork) 修改为 inline _syscall0(int,fork) static inline _syscall0(int,pause) 修改为 inline _syscall0(int,pause) static inline _syscall1(int,setup,void *,BIOS) 修改为 inline _syscall1(int,setup,void *,BIOS) static inline _syscall0(int,sync) 修改为 inline _syscall0(int,sync) make 报错: -r -o kernel.o sched.o system_call.o traps.o asm.o fork.o panic.o printk.o vsprintf.o sys.o exit.o signal.o mktime.o ld: 并不支持从格式 elf32-i386 (sched.o) 到格式 elf64-x86-64 (kernel.o) 的重寻址链结 给ld命令添加","tags":[]},{"title":"我的docker学习笔记","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/我的docker学习笔记/","text":"查找指定container: 我想用docker实现这样的功能: 配置一个Linux 0.11的学习环境,VNCServer + noVNC,并在宿主机中建一个目录保存我的数据 下面正文开始了, FROM ubuntu:trusty","tags":[]},{"title":"vs2015环境编译libcurl","date":"2017-03-29T16:00:00.000Z","path":"2017/03/30/vs2015环境编译openssl/","text":"1&gt; 需要下载的文件: curl-7.53.1.zip, openssl-1.0.2j.tar.gz 2&gt; VS2015IDE, NASM汇编器 使用汇编器NASM编译OpenSSL库: 解压openssl-1.0.2j.tar.gz到D:\\Develop\\, cd D:\\Develop\\openssl-1.0.2j,我需要的是静态库,执行下面三条命令: perl Configure VC-WIN32 –prefix=openssl_lib nmake -f ms\\nt.mak nmake -f ms\\nt.mak install 大概等待十分钟,在当前目录下会生成所需要的openssl_lib文件夹 编译libcurl 解压curl-7.53.1.zip到D:\\Develop, cd D:\\Develop\\curl-7.53.1\\winbuild, 查看帮助: nmake /f Makefile.vc, 开始编译: nmake /f Makefile.vc mode=static VC=14 WITH_DEVEL=D:\\Develop\\openssl-1.0.2j\\openssl_lib WITH_SSL=static ENABLE_SSPI=no ENABLE_IPV6=no 命令注释 mode=dll 编译libcurl位动态链接库，如果static 就是把libcurl编译位静态库 VC=10 代表使用的是VC2010 WITH_DEVEL=C:\\openssl_lib 表示用到第三方开发包的目录，本例上面已经将openssl编译好的开发包，安装到此目录 WITH_SSL=static ,代表使用libssl库 是静态库 ENABLE_SSPI=no ENABLE_IPV6=no（禁用SSPI，ipV6功能） 稍等片刻就编译成功了。 不过,上面的编译是没有问题的,运行的时候会有问题: 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_cleanup 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_getinfo 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_setopt 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_slist_append 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_init 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_global_init 1&gt;HttpWebRequest.obj : error LNK2001: 无法解析的外部符号 impcurl_easy_perform 解决办法是: 加入预编译选项：项目-&gt;属性-&gt;c/c++ -&gt;预处理器-&gt;预处理器，添加一条:BUILDING_LIBCURL 总结自: http://www.cnblogs.com/openiris/p/3812443.html http://blog.csdn.net/varding/article/details/5329023 学习是一种乐趣.","tags":[]},{"title":"信号","date":"2017-03-25T16:00:00.000Z","path":"2017/03/26/信号/","text":"什么是信号?信号就是软中断 什么是软中断?软中断就是软件模拟的中断 什么是中断中断服务程序 信号是进程的异步通信机制. 系统提供的信号如何查看kill -l 一般来说,信号有64个信号kill -信号编号 pid 信号产生,信号阻塞,信号未决,进程对信号的捕获,信号处理程序 进程对信号的默认处理动作是终止进程用户可以根据自己的需求设置进程对信号的处理SIG_DFL 缺省SIG_IGN 忽略用户自定义信号处理函数 需要向进程注册一个函数,当信号到来的时候,使用这个注册的信号处理函数来处理信号到达. 使用signal(2)注册信号处理函数","tags":[]},{"title":"Linux 程序与进程","date":"2017-03-23T16:00:00.000Z","path":"2017/03/24/Linux 程序与进程/","text":"程序是完成特定任务的一系列指令集合 从用户的角度来看进程是程序的一次动态执行过程从操作系统的核心来看，进程是操作系统分配的内存、CPU时间片等资源的基本单位。进程是资源分配的最小单位每一个进程都有自己独立的地址空间与执行状态。 进程结构 进程的静态描述：由三部分组成:PCB、有关程序段和相关数据结构集。 进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。 多进程间的关系,fork? 在进程空间里加载新的映像exec","tags":[]},{"title":"X86汇编 转移指令","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/X86汇编 转移指令/","text":"操作符offset: 取得标号的偏移地址 1234start: mov ax,offset start ;相当于mov ax,0s: mov ax,offset s ;相当于mov ax,3 根据位移进行转移: jmp short 标号, 转到标号处执行指令(段内短转移),(IP)=(IP)+8位位移 jmp near ptr 标号, 转到标号处执行指令(段内短转移),(IP)=(IP)+16位位移 jmp far ptr 标号, 段间转移(源转移),(CS)=标号所在段的段地址, (IP)=标号在段中的偏移地址,far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP 地址在寄存器中的转移: “jmp 16位reg”,(IP)= (16位reg) 地址在内存地址中的转移: “jmp word ptr 内存单元地址(段内转移)”: 从内存单元地址处存放着一个字,是转移的目的偏移地址 123mov ax,0123hmov ds:[0],axjmp word ptr ds:[0] ;执行后 &quot;jmp dword ptr 内存单元地址(段间转移)&quot;, 高地址处的字是目的段地址,低地址处的字是目的偏移地址 (CS)=(内存单元地址+2) (IP)=(内存单元地址)","tags":[]},{"title":"进程","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/进程/","text":"一, 进程映射 代码段: 字符串,常量数据段: 全局变量,静态局部变量堆: 使用malloc等一系列函数向系统申请的内存空间在堆里栈: 自动局部变量和形参 注意变量的生命周期和作用域 二, 使用mmap将物理地址映射到进程的虚拟地址空间 处理这个映射,需要使用mmap和munmap 123456789#include &lt;sys/mman.h&gt;//功能: 映射文件或设备到内存空间(虚拟地址空间)//返回值: 若错误,返回MAP_FAILED, errno被设置, 若成功,返回映射区域的地址void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); //功能: 解除内存映射//返回值: 0 成功, 1 失败int munmap(void *addr, size_t length);","tags":[]},{"title":"Linux c文件操作","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/Linux c文件操作/","text":"open(2),close(2),read(2),write(2),lseek(2) 1234//打开文件int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);//返回值:-1,错误,重置errno O_EXCL: 与O_CREAT一起指定.文件存在报错 O_CREATE: 如果文件不存在,则创建文件,需要提供文件的权限.权限的有效性是提供的权限和umask的运算结果 若是新的文件,则可以设置权限mode,文件最终的权限计算规则是:mode &amp; ~umask, mask是权限掩码(默认不要的权限) O_TRUNC: 文件存在就清空 补充:-rw-r–r– 1 root root 517 2月 24 21:09 02_25.cpp第一个字符决定了文件的类型: ‘-‘表示普通文件,’d’表示目录文件,’b’块设备文件,’c’字符设备文件,’s’socket文件,l软链接文件,p管道文件 //打开文件,若存在,报错 open(argv[1], O_RDWR | O_CREAT | O_EXCL, 0664); umask:777==&gt;111 111 111 110 100 100 touch test.txt———- 1 root root 367 3月 17 05:39 test_dynamic.c权限:0000 110 100 100umask:022==&gt;000 010 010 111 101 101-rw-r–r– 1 root root 0 3月 21 03:09 c权限: 文件描述符中:STDIN_","tags":[]},{"title":"mmap函数引起的分析","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/mmap函数引起的分析/","text":"http://www.cnblogs.com/huxiao-tee/p/4660352.html http://blog.csdn.net/lixungogogo/article/details/52210750","tags":[]},{"title":"Unix C程序中的错误处理","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/Unix C的一般处理/","text":"一, Unix C程序中的错误处理 系统提供了一个全局变量 errno 如何根据错误编号获取错误信息? perror函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;void perror(const char *s);//man 3 perror//功能:打印一个系统错误信息//参数:s 自定义的提示//例子:#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], &quot;r&quot;); if(fp==NULL)&#123;//发生错误时 perror(&quot;fopen&quot;);//输出错误信息到显示器 return 1; &#125; printf(&quot;open file success!\\n&quot;); fclose(fp); return 0;&#125;//shell终端:root@kali:~/maxu# gcc test.c &amp;&amp; ./a.out abc.hello//显示:fopen: No such file or directory#include &lt;string.h&gt;char *strerror(int errnum);//man 3 strerror//功能:根据errnum,返回描述errnum的错误信息,如果errnum找不到,返回&quot;Unknown &quot;//参数:errnum 错误编号//例子:#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//这个头文件中存在声明:int errno;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], &quot;r&quot;); if(fp==NULL)&#123;//发生错误时 printf(&quot;errno: %d\\n&quot;, errno); printf(&quot;%s\\n&quot;, strerror(errno)); return 1; &#125; printf(&quot;open file success...\\n&quot;); fclose(fp); return 0;&#125;//shell:root@kali:~/maxu# ./a.out a//输出:errno: 2No such file or directory 补充:标准输入 键盘 0标准输出 显示器 1标准错误输出 显示器 2 帮助的使用:man 1 命令man 2 系统调用函数的名字man 3 库函数的名称 三, 进程映射","tags":[]},{"title":"GDB调试器的使用","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/GDB调试器的使用/","text":"第一步: 在编译链接源文件成可执行文件的时候,加参数: -g, 生成的可执行文件带有调试信息 1root@kali:~/maxu/test_lib# gcc -g *.c -o tt 第二步: 使用gdb调试工具,调试带有调试信息的可执行文件1root@kali:~/maxu/test_lib# gdb tt 第三步: 执行相关调试指令 l 列出程序代码(list) b 5 为第5行设置断点(break) r 运行可执行程序(运行到下一个断点前,比如上面的第五行,未执行第五行)(run) p a 显示a变量的值(print) n 执行下一条语句(next) s 按步执行语句,有函数就进入函数内(step) q 离开gdb(quit)","tags":[]},{"title":"gcc简单教程","date":"2017-03-18T16:00:00.000Z","path":"2017/03/19/gcc简单教程/","text":"GCC(GNU Compiler Collection)是Linux下最常用的C语言编译器，是GNU项目中符合ANSI C标准的编译系统,能够编译用C、C++和Object C等语言编写的程序。同时它可以通过不同的前端模块来支持各种语言，如Java、Fortran、Pascal、Modula-3和Ada等。 一. CC编译程序有四个阶段 预处理（Pre-Processing）编译（Compiling）汇编（Assembling）链接（Linking） 1.1 预处理 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容1gcc -E test.c 或 gcc -E test.c -o test.i -E进行预处理后结束-o用于指定输出(out)文件名 1.2 编译为汇编代码 编译过程完成后，将生成程序的汇编代码test.s1gcc -S test.i -o test.s 1.3 汇编 这一步会为每一个源文件产生一个目标文件1gcc -c test.c –o test.o 1.4 链接1gcc -c test.c –o test.o 二. 静态库的制作与使用1,将相关源文件编译为目标文件gcc -c *.c 2,将目标文件添加到静态库中ar -r libmymath.a *.o 3,使用静态库链接目标文件形成可执行程序gcc test.o -Ltest_lib -lmymath test.o是main函数所在的文件,L是链接文件的路径,l是链接库的名字 三. 动态库的制作与使用动态库的命名: lib+库名.so1,将相关源文件编译为与位置无关的目标文件gcc -c -fPIC *c 2,将目标文件添加到动态库中 gcc -shared -o libmymath.so *.o 3,将动态库链接到目标文件中gcc test.c -Ltest_lib -lmymath -o tt -std=c99 ./tt: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory ldd tt//使用ldd命令查看可执行依赖的动态库文件告诉加载器动态库文件的路径,两种方式:使用环境变量LD_LIBRARY_PATH指定加载器的寻找路径.LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./test_lib 四. 动态加载动态库函数按需加载动态库中的一个或多个函数.需要使用系统提供的以下函数: void dlopen(const char filename, int flags); Link with -ldl: 编译时需要加上 补充: nm命令的使用 nm 二进制文件名 $ nm add.o 00000000 T t_add 0000000e T t_sub T 代表了add.o文件中包含了t_add和t_sub函数的实现代码。 $ nm test.o 00000000 T main U printf U t_add U t_div U t_mul U t_sub U 代表了在该文件中使用到了这个函数，但是没有这个函数的实现代码。 链接的过程，就是多个文件拼接成一个可执行文件的过程。 目前的链接过程是发生在编译的时候，这个链接称为静态链接。 动态链接是在代码加载到内存执行的时候发生的。","tags":[]},{"title":"vim使用技巧","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/vim使用技巧/","text":"1,查找指定字符,/第一个出现的字符串,?最后一个出现的字符串 eg: :/abc :?abc 2,后退:命令模式下按u3,剪切当前行以下5行:命令模式下,5dd, 粘贴到当前位置的下一行,命令模式下,p4,自动补全:Ctrl+n 5,挂起,转到终端:Ctrl+z, 继续之前挂起的vim: fg 1","tags":[]},{"title":"使用Hexo+Github部署个人博客","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/使用Hexo+Github部署个人博客/","text":"​ 选一个好一点的用户名来注册一个github帐号,这个用户名会成为你的静态网站的域名的一部分(userName.github.io),开通个人静态站点 安装git,nodejs,安装完毕后,打开git-gui(就是因为git-gui好看点,也打开cmd), 12345cd /e/Platform/Gitnpm install -g hexo-clihexo init blogcd blognpm install 执行完后,你的目录是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 然后,执行 1234hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这时,在浏览器中打开 http://localhost:4000 ,就可以访问你的本地站点了","tags":[]},{"title":"学习使用汇编的调试工具debug","date":"2017-03-14T16:00:00.000Z","path":"2017/03/15/学习使用汇编的调试工具debug/","text":"R命令查看、改变CPU寄存器内容； D命令查看内存中的内容； D [段地址:偏移地址] E命令修改内存中的内容； E 段地址:起始偏移地址 数据1 数据2……… U命令将内存中机器指令翻译成汇编指令； 显示三个部分的内容: 左边为内存地址，其次为机器码 最右边机器码对应的汇编指令。 T命令执行一条机器指令； A命令以汇编指令的格式在内存中写入一条机器指令；","tags":[]},{"title":"linux启动ssh","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/linux启动ssh/","text":"sudo apt-get install openssh-server 安装ssh ps -e |grep ssh 查看是否已启动 systemctl is-enabled ssh 判断ssh是否是开机启动 systemctl enable ssh 设置ssh开机启动 systemctl status ssh 查看ssh状态 1),如果报错:algorithm negotiation failed 解决方法:添加下面的内容到/etc/ssh/sshd_config末尾(3行): Ciphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbc MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96 KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org 2),使用root帐号,密码是对的,但是Permission denied,可能是因为: 默认禁用root帐号,修改/etc/ssh/sshd_config文件,设置PermitRootLogin: PermitRootLogin yes","tags":[]}]