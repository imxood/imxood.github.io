[{"title":"GDB调试器的使用","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/GDB调试器的使用/","text":"第一步: 在编译链接源文件成可执行文件的时候,加参数: -g, 生成的可执行文件带有调试信息 1root@kali:~/maxu/test_lib# gcc -g *.c -o tt 第二步: 使用gdb调试工具,调试带有调试信息的可执行文件1root@kali:~/maxu/test_lib# gdb tt 第三步: 执行相关调试指令 l 列出程序代码(list) b 5 为第5行设置断点(break) r 运行可执行程序(运行到下一个断点前,比如上面的第五行,未执行第五行)(run) p a 显示a变量的值(print) n 执行下一条语句(next) s 按步执行语句,有函数就进入函数内(step) q 离开gdb(quit)","tags":[]},{"title":"Unix C程序中的错误处理","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/Unix C的一般处理/","text":"一, Unix C程序中的错误处理 系统提供了一个全局变量 errno 如何根据错误编号获取错误信息? perror函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;void perror(const char *s);//man 3 perror//功能:打印一个系统错误信息//参数:s 自定义的提示//例子:#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], &quot;r&quot;); if(fp==NULL)&#123;//发生错误时 perror(&quot;fopen&quot;);//输出错误信息到显示器 return 1; &#125; printf(&quot;open file success!\\n&quot;); fclose(fp); return 0;&#125;//shell终端:root@kali:~/maxu# gcc test.c &amp;&amp; ./a.out abc.hello//显示:fopen: No such file or directory#include &lt;string.h&gt;char *strerror(int errnum);//man 3 strerror//功能:根据errnum,返回描述errnum的错误信息,如果errnum找不到,返回&quot;Unknown &quot;//参数:errnum 错误编号//例子:#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//这个头文件中存在声明:int errno;int main(int argc, char *argv[])&#123; FILE *fp; fp=fopen(argv[1], &quot;r&quot;); if(fp==NULL)&#123;//发生错误时 printf(&quot;errno: %d\\n&quot;, errno); printf(&quot;%s\\n&quot;, strerror(errno)); return 1; &#125; printf(&quot;open file success...\\n&quot;); fclose(fp); return 0;&#125;//shell:root@kali:~/maxu# ./a.out a//输出:errno: 2No such file or directory 补充:stdio 标准输入 键盘stdout 标准输出 显示器stderr 标准错误输出 显示器 帮助的使用:man 1 命令man 2 系统调用函数的名字man 3 库函数的名称 三, 进程映射","tags":[]},{"title":"gcc简单教程","date":"2017-03-18T16:00:00.000Z","path":"2017/03/19/C语言学习/","text":"GCC(GNU Compiler Collection)是Linux下最常用的C语言编译器，是GNU项目中符合ANSI C标准的编译系统,能够编译用C、C++和Object C等语言编写的程序。同时它可以通过不同的前端模块来支持各种语言，如Java、Fortran、Pascal、Modula-3和Ada等。 一. CC编译程序有四个阶段 预处理（Pre-Processing）编译（Compiling）汇编（Assembling）链接（Linking） 1.1 预处理 预处理用于将所有的#include头文件以及宏定义替换成其真正的内容1gcc -E test.c 或 gcc -E test.c -o test.i -E进行预处理后结束-o用于指定输出(out)文件名 1.2 编译为汇编代码 编译过程完成后，将生成程序的汇编代码test.s1gcc -S test.i -o test.s 1.3 汇编 这一步会为每一个源文件产生一个目标文件1gcc -c test.c –o test.o 1.4 链接1gcc -c test.c –o test.o 二. 静态库的制作与使用1,将相关源文件编译为目标文件gcc -c *.c 2,将目标文件添加到静态库中ar -r libmymath.a *.o 3,使用静态库链接目标文件形成可执行程序gcc test.o -Ltest_lib -lmymath test.o是main函数所在的文件,L是链接文件的路径,l是链接库的名字 三. 动态库的制作与使用动态库的命名: lib+库名.so1,将相关源文件编译为与位置无关的目标文件gcc -c -fPIC *c 2,将目标文件添加到动态库中 gcc -shared -o libmymath.so *.o 3,将动态库链接到目标文件中gcc test.c -Ltest_lib -lmymath -o tt -std=c99 ./tt: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory ldd tt//使用ldd命令查看可执行依赖的动态库文件告诉加载器动态库文件的路径,两种方式:使用环境变量LD_LIBRARY_PATH指定加载器的寻找路径.LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./test_lib 四. 动态加载动态库函数按需加载动态库中的一个或多个函数.需要使用系统提供的以下函数: void dlopen(const char filename, int flags); Link with -ldl: 编译时需要加上","tags":[]},{"title":"使用Hexo+Github部署个人博客","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/使用Hexo+Github部署个人博客/","text":"​ 选一个好一点的用户名来注册一个github帐号,这个用户名会成为你的静态网站的域名的一部分(userName.github.io),开通个人静态站点 安装git,nodejs,安装完毕后,打开git-gui(就是因为git-gui好看点,也打开cmd), 12345cd /e/Platform/Gitnpm install -g hexo-clihexo init blogcd blognpm install 执行完后,你的目录是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 然后,执行 1234hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这时,在浏览器中打开 http://localhost:4000 ,就可以访问你的本地站点了","tags":[]},{"title":"vim使用技巧","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/vim使用技巧/","text":"1,查找指定字符: /第一个出现的字符串 ?最后一个出现的字符串 eg: :/abc :?abc","tags":[]},{"title":"linux启动ssh","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/linux启动ssh/","text":"sudo apt-get install openssh-server 安装ssh ps -e |grep ssh 查看是否已启动 systemctl is-enabled ssh 判断ssh是否是开机启动 systemctl enable ssh 设置ssh开机启动 systemctl status ssh 查看ssh状态 1),如果报错:algorithm negotiation failed 解决方法:添加下面的内容到/etc/ssh/sshd_config末尾(3行): Ciphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbc MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96 KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org 2),使用root帐号,密码是对的,但是Permission denied,可能是因为: 默认禁用root帐号,修改/etc/ssh/sshd_config文件,设置PermitRootLogin: PermitRootLogin yes","tags":[]}]