<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>学习笔记</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">首页</a></li><li class="chapter-item expanded affix "><li class="part-title">文章</li><li class="chapter-item expanded "><div>硬件</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hardware/二极管.html">二极管</a></li><li class="chapter-item "><a href="hardware/三极管.html">三极管</a></li><li class="chapter-item "><a href="hardware/MOS管.html">MOS管</a></li><li class="chapter-item "><a href="hardware/门电路.html">门电路</a></li></ol></li><li class="chapter-item expanded "><div>嵌入式</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>ESP32</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embedded/esp32/nanoESP32-C3.html">nanoESP32-C3</a></li></ol></li><li class="chapter-item "><div>STM32</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embedded/stm32 开发环境.html">Stm32 开发环境</a></li></ol></li><li class="chapter-item "><div>RT-thread</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embedded/rt-thread/art-pi.html">rt-thread</a></li></ol></li><li class="chapter-item "><a href="embedded/Rust嵌入式.html">Rust嵌入式</a></li><li class="chapter-item "><a href="embedded/C语言.html">C语言</a></li><li class="chapter-item "><a href="embedded/gdb.html">GDB</a></li><li class="chapter-item "><a href="embedded/GPIO和AFIO.html">GPIO和AFIO</a></li><li class="chapter-item "><div>传感器</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embedded/传感器/ws2812.html">ws2812</a></li></ol></li><li class="chapter-item "><a href="embedded/lvgl.html">LVGL</a></li></ol></li><li class="chapter-item expanded "><div>设计</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design/blender.html">Blender</a></li></ol></li><li class="chapter-item expanded "><div>编程语言</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Rust</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="program/rust/rust后端.html">Rust后端</a></li><li class="chapter-item "><div>Game</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="program/rust/game/bevy.html">Bevy</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><div>前端</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frontend/web.html">Web</a></li><li class="chapter-item "><a href="frontend/nodejs.html">Nodejs</a></li><li class="chapter-item "><a href="frontend/electron+neon.html">Electrin+Neno</a></li><li class="chapter-item "><a href="frontend/vue/vue.html">Vue</a></li></ol></li><li class="chapter-item expanded "><div>工具</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tools/github.html">github</a></li><li class="chapter-item "><a href="tools/markdown.html">markdown</a></li><li class="chapter-item "><a href="tools/mdbook.html">mdbook</a></li><li class="chapter-item "><a href="tools/linux/linux工具.html">linux工具</a></li><li class="chapter-item "><a href="tools/aliyun服务.html">aliyun服务</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">学习笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/imxood/imxood.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="学而时习之"><a class="header" href="#学而时习之">学而时习之</a></h1>
<h2 id="学习计划"><a class="header" href="#学习计划">学习计划</a></h2>
<ul>
<li>学习 egui 源码</li>
<li>async wake unpin 分析: https://github.com/zesterer/pollster</li>
<li>学习 wgpu</li>
<li>解读 rustdesk 源码</li>
</ul>
<h3 id="常读书-读好书"><a class="header" href="#常读书-读好书">常读书, 读好书</a></h3>
<img width="70%" src="./images/读书.jpg">
<p>本笔记由 <a href="https://github.com/rust-lang/mdBook">mdbook</a> 构建</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="二极管"><a class="header" href="#二极管">二极管</a></h1>
<h2 id="n型半导体-和-p型半导体"><a class="header" href="#n型半导体-和-p型半导体">N型半导体 和 P型半导体</a></h2>
<p>在N型半导体中掺入五价元素, 在与周围的硅原子形成共价键后, 还多出一个电子, 多出的电子不受共价键的约束, 只需很少的能量就成为自由电子. N型半导体中, 自由电子是多子, 空穴是少子</p>
<p>在P型半导体中掺入三价元素, 在与周围的硅原子形成共价键后, 会就产生了一个空位, 当硅原子的外层电子填补空位时, 硅原子的共价键中便产生一个空穴. P型半导体中, 空穴是多子, 自由电子是少子</p>
<h2 id="pn结"><a class="header" href="#pn结">PN结</a></h2>
<p><a href="https://www.bilibili.com/video/BV15T4y1L796">二极管 工作原理 How does a Diode work</a></p>
<p><a href="http://blog.sciencenet.cn/blog-729147-1033899.html">张云 - PN结的动画</a></p>
<p>P型半导体和N型半导体构成PN结后, N区的电子(多子)会扩散到P区, 和P区的空穴结合, 于是N区产生了正离子, P区产生了负离子, 正离子和负离子之间形成了内电场, 内电场会阻碍扩散运动, 内电场也会让P区的电子(少子)向N区漂移</p>
<p>慢慢地, 当N区的电子浓度降低, 扩散运动减弱, 但是由于内电场是在不断增强, 所以漂移运动在不断增强, 直到扩散运动和漂移运动达到平衡</p>
<p>在无外电场和外部激发下, 参与扩散的多子与参与漂移的少子 数目相同, 从而达到动态平衡, 形成的这个内电场区域称之为PN结, 或: 阻挡层、耗尽层、空间电荷区.</p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-PN%E7%BB%931.gif" alt="" /></p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-PN%E7%BB%932.gif" alt="" /></p>
<h2 id="pn结-的-正向电压"><a class="header" href="#pn结-的-正向电压">PN结 的 正向电压</a></h2>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-PN%E7%BB%93%E6%AD%A3%E5%90%91%E5%81%8F%E7%BD%AE1.gif" alt="" /></p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-PN%E7%BB%93%E6%AD%A3%E5%90%91%E5%81%8F%E7%BD%AE2.gif" alt="" /></p>
<h2 id="pn结-的-反向电压"><a class="header" href="#pn结-的-反向电压">PN结 的 反向电压</a></h2>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-PN%E7%BB%93%E5%8F%8D%E5%90%91%E5%81%8F%E7%BD%AE1.gif" alt="" /></p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-PN%E7%BB%93%E5%8F%8D%E5%90%91%E5%81%8F%E7%BD%AE2.gif" alt="" /></p>
<p>在低掺杂的情况下, 耗尽层较宽, 当加很小的反向电压, 相当于是增强了内电场, 于是就加剧了少子的漂移运动, 同时多子的扩散作用也会加剧, 所以耗尽层会变窄, 并达到新的平衡.</p>
<p>在高掺杂的情况下, 耗尽层很窄, 当加很小的反向电压, 就会加剧少子的漂移运动, 在耗尽层形成很强的电场, 而直接破坏共价键, 使价电子脱离共价键的束缚, 产生电子-空穴对, 使电流急剧增大.</p>
<p>在很低的反向电压时, 就引起电流急剧增大, 这被称为齐纳击穿, 如果反向电压继续增大, 新产生的电子-空穴对被电场加速后又撞出其它的价电子, 载流子雪崩式倍增, 就产生了雪崩击穿.</p>
<h2 id="为什么在掺杂浓度高的区域-空间电荷区更窄"><a class="header" href="#为什么在掺杂浓度高的区域-空间电荷区更窄">为什么在掺杂浓度高的区域 空间电荷区更窄</a></h2>
<p>结合的 N型半导体 和 P型半导体, 原子的密度应该是一样的, 只是掺杂的元素浓度不同.</p>
<p>因为N区电子与P区空穴结合才形成了N区正离子和P区的负离子, 这些正负离子是成对出现的, 如果掺杂浓度不同, 那么产生相同数量的正负离子数量所需的体积就不同. 掺杂浓度越高, 所需体积就越少, 所以 在掺杂浓度高的区域 空间电荷区更窄</p>
<h2 id="稳压管工作原理"><a class="header" href="#稳压管工作原理">稳压管工作原理</a></h2>
<p>齐纳二极管又叫稳压二极管</p>
<p>稳压二极管的伏安特性, 如图.</p>
<p>正向偏置状态下, 稳压二极管表现为普通二极管的伏安特性, 即正向特性为指数曲线.
当反向电压增大到一定数值时则击穿, 击穿区的曲线很陡, 几乎平行于纵轴, 表现为很好的稳压特性</p>
<p><img src="hardware/images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E7%A8%B3%E5%8E%8B%E4%BA%8C%E6%9E%81%E7%AE%A1.png" alt="" /></p>
<h2 id="整流管工作原理"><a class="header" href="#整流管工作原理">整流管工作原理</a></h2>
<p>原理:</p>
<p>二极管整流利用了它具有单向导电性, 也就是电流只能从正极流向负极, 而不能从负极流向正极.</p>
<p>只有二极管两端加正向电压并且大于一定值时, 二极管才会导通, 导通后电阻很小, 相当于一根导线.</p>
<p>而在二极管两端加反向电压时, 二极管因为内部PN结的关系, 反向电流很小, 可以忽略不计, 可以看作是截止状态.</p>
<h3 id="半波整流电路"><a class="header" href="#半波整流电路">半波整流电路</a></h3>
<p>参考: <a href="https://www.diangon.com/thread-34486-1-1.html">二极管整流电路工作原理图解</a></p>
<p>半波整流电路:</p>
<p><img src="hardware/images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E5%8D%8A%E6%B3%A2%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF.png" alt="" /></p>
<p>半波整流电路波形:</p>
<p><img src="hardware/images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E5%8D%8A%E6%B3%A2%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF%E6%B3%A2%E5%BD%A2.png" alt="" /></p>
<p>220V/50Hz交流电经过变压器输出U2, U2也是正弦交流电压, 大小和方向不断变化.</p>
<p>当正半周流过二极管时, A点电位处于高电平, B点电位处于低电平, 二极管处于正向偏置, 此时二极管导通.</p>
<p>当负半周流向二极管时, A点电位低于B点电位, 二极管反偏, 处于截至状态, 没有电流流过.</p>
<p>产生的波形只在一个方向上变化, 称这种为脉动直流电</p>
<h3 id="桥式整流电路"><a class="header" href="#桥式整流电路">桥式整流电路</a></h3>
<p>参考: <a href="https://www.eet-china.com/mp/a10091.html">秒懂桥式整流工作原理(动画)</a></p>
<p>变压器u2正半周时电流通路:</p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E6%A1%A5%E5%BC%8F%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF1.gif" alt="" /></p>
<p>变压器u2负半周时电流通路:</p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E6%A1%A5%E5%BC%8F%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF2.gif" alt="" /></p>
<p>整个周期电流通路是这样的:</p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E6%A1%A5%E5%BC%8F%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF3.gif" alt="" /></p>
<p>桥式整流电路输出波形与全波整流电路的一样, 也是全波波形, 所以整流后输出电压是整流前的0.9倍</p>
<p><img src="hardware/./images/%E4%BA%8C%E6%9E%81%E7%AE%A1-%E6%A1%A5%E5%BC%8F%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF4.gif" alt="" /></p>
<p>总结:</p>
<ul>
<li>画图时要注意4只整流二极管连接方法.</li>
<li>电源变压器次级线圈不需要抽头.</li>
<li>每一个半周交流输入电压期间, 有2只整流二极管同时串联导通, 另外2只整流二极管截止.</li>
<li>桥式整流电路输出波形是全波波形</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三极管"><a class="header" href="#三极管">三极管</a></h1>
<h2 id="箭头方向"><a class="header" href="#箭头方向">箭头方向</a></h2>
<p><strong>箭头只能从P到N，所以根据箭头指向即可确定三极管是PNP型还是NPN型</strong></p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1.png" alt="" /></p>
<h2 id="基本电路"><a class="header" href="#基本电路">基本电路</a></h2>
<p>$\Delta u_{I}$ 表示输入信号, $\Delta u_{O}$ 表示输出信号</p>
<p>基极 发射极 输入信号 构成输入回路, 集电极,发射极输出信号构成输出回路.</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E5%9F%BA%E6%9C%AC%E5%85%B1%E5%B0%84%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF.png" alt="" /></p>
<h2 id="三极管内部电流"><a class="header" href="#三极管内部电流">三极管内部电流</a></h2>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A11.png" alt="" /></p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1%E5%86%85%E9%83%A8%E7%94%B5%E6%B5%81.png" alt="" /></p>
<p>NPN管特点: 1. <code>上层的发射极掺杂浓度很高</code>, 2. <code>中间的基极很薄, 掺杂浓度很低</code>, 3. <code>下层的集电极面积很大</code></p>
<h2 id="三极管的输入输出特性"><a class="header" href="#三极管的输入输出特性">三极管的输入输出特性</a></h2>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E8%BE%93%E5%85%A5%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png" alt="" /></p>
<h2 id="三极管输出特性"><a class="header" href="#三极管输出特性">三极管输出特性</a></h2>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png" alt="" /></p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7.png" alt="" /></p>
<h2 id="为什么小电流ib能控制大电流ic的大小-以及放大电路的原理"><a class="header" href="#为什么小电流ib能控制大电流ic的大小-以及放大电路的原理">为什么小电流Ib能控制大电流Ic的大小, 以及放大电路的原理</a></h2>
<p>参考: <a href="http://blog.sciencenet.cn/blog-729147-1041542.html">张云 - 三极管的动画</a></p>
<p>这里的三极管是双极型晶体管, 模电的放大电路和数电的简单逻辑电路里面都会用到.
有集电极c、基极b、发射极e、以及两个PN结：集电结和发射结. 集电极面积比较大, 基极厚度薄而且载流子浓度比较低.</p>
<p>下图是个NPN型的三极管:</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-NPN%E5%9E%8B.png" alt="" /></p>
<p>当发射结正偏时, 电荷分布会发生变化, 发射结宽度会变窄;相当于给电子打开了一扇e到b的大门</p>
<p>集电结反偏时, 电荷分布会也发生变化, 集电结宽度会变宽. 相当于打开了阻碍电子从c极跑出去的大门, 如下方动画所示:</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF1.gif" alt="" /></p>
<p>b极会接一个大电阻RB限制电流Ib的大小, 跑到b极的那些多余的电子就只好穿越集电结, 形成电流Ic, 如下方动画所示：</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF2.gif" alt="" /></p>
<p>如果基极电压翻倍, 电荷分布会继续发生变化, 发射结宽度会变得更窄, 这扇大门变得更宽了, 将会有更多的电子跑到b极. 如下方动画所示:</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF3.gif" alt="" /></p>
<p>由于RB是大电阻, Ib就算翻倍了也还是很小, 所以更多的电子会穿越集电结, 让Ic也翻倍. 如下方动画所示:</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF4.gif" alt="" /></p>
<p>两个直流电源是可以合并到一起的, 再加上小信号ui和两个电容, 就得到了放大电路, 如下图所示:</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF5.png" alt="" /></p>
<p>如果电阻大小合适, 这个放大电路能够将小信号$u_i$放大成相位相反的大信号$u_{CE}$, 如下方动画所示:</p>
<p><img src="hardware/images/%E4%B8%89%E6%9E%81%E7%AE%A1-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF6.gif" alt="" /></p>
<p>红色为输入端, $u_i$的变化会影响$U_{BE}$, 把发射结看成一个小电阻, 红色的Q点就会沿黑线运动, 然后画出$i_B$的图像;
根据$i_C$=$\Beta i_B$,画出$i_C$的图像, 纵坐标从$\mu A$变成了$mA$;
而输出端有$U_{CE}=U_{CC}-I_CR_C$, 当$U_{CC}$、$R_C$不变时, $U_{CE}$与$I_C$反相</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mos管"><a class="header" href="#mos管">MOS管</a></h1>
<p>参考: <a href="https://wenku.baidu.com/view/fc0a7d2eccbff121dd3683b2.html">MOS管原理,非常详细</a></p>
<p>参考: <a href="https://blog.csdn.net/weixin_32821257/article/details/112181812">超低内阻mos管-MOS总结</a></p>
<h2 id="三个极怎么判定"><a class="header" href="#三个极怎么判定">三个极怎么判定</a></h2>
<p><img src="hardware/images/%E4%B8%89%E4%B8%AA%E6%9E%81%E6%80%8E%E4%B9%88%E5%88%A4%E5%AE%9A.png" alt="" /></p>
<h2 id="是n沟道还是p沟道"><a class="header" href="#是n沟道还是p沟道">是N沟道还是P沟道</a></h2>
<p><img src="hardware/images/N%E6%B2%9F%E9%81%93.png" alt="" /></p>
<p><img src="hardware/images/P%E6%B2%9F%E9%81%93.png" alt="" /></p>
<h2 id="寄生二极管的方向如何判定"><a class="header" href="#寄生二极管的方向如何判定">寄生二极管的方向如何判定</a></h2>
<p><img src="hardware/images/%E5%AF%84%E7%94%9F%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E6%96%B9%E5%90%91.png" alt="" /></p>
<p><img src="hardware/images/%E5%AF%84%E7%94%9F%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E6%96%B9%E5%90%911.png" alt="" /></p>
<h2 id="mos管用作开关时在电路中的连接方法"><a class="header" href="#mos管用作开关时在电路中的连接方法">MOS管用作开关时在电路中的连接方法</a></h2>
<p><img src="hardware/images/MOS%E7%AE%A1%E7%94%A8%E4%BD%9C%E5%BC%80%E5%85%B3%E6%97%B6%E5%9C%A8%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E6%B3%95.png" alt="" /></p>
<p><img src="hardware/images/MOS%E7%AE%A1%E7%94%A8%E4%BD%9C%E5%BC%80%E5%85%B3%E6%97%B6%E5%9C%A8%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E6%B3%95-%E5%8F%8D%E8%AF%81.png" alt="" /></p>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p><img src="hardware/images/NMOS%E7%AE%A1%E5%BA%94%E7%94%A8-%E4%BF%A1%E5%8F%B7%E5%88%87%E6%8D%A2.png" alt="" /></p>
<p><img src="hardware/images/NMOS%E7%AE%A1%E5%BA%94%E7%94%A8-%E7%94%B5%E5%8E%8B%E9%80%9A%E6%96%AD.png" alt="" /></p>
<p><img src="hardware/images/PMOS%E7%AE%A1%E5%BA%94%E7%94%A8-%E7%94%B5%E5%8E%8B%E9%80%9A%E6%96%AD.png" alt="" /></p>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<p>一般主板上使用最多的是<strong>增强型MOS管</strong></p>
<p><strong>NMOS最多, 一般多用在信号控制上</strong></p>
<p>其次是<strong>PMOS, 多用在电源开关等方面</strong></p>
<p><strong>耗尽型几乎不用</strong></p>
<h2 id="与三极管的区别"><a class="header" href="#与三极管的区别">与三极管的区别</a></h2>
<p>三极管是电流控制, MOS管是电压控制, 主要有如下的区别:</p>
<ol>
<li>
<p>只容许从信号源取少量电流的情况下, 选用MOS管；在信号电压较低, 有容许从信号源取较多电流的条件下, 选用三极管.</p>
</li>
<li>
<p>MOS管是单极性器件(靠一种多数载流子导电), 三极管是双极性器件(既有多数载流子, 也要少数载流子导电).</p>
</li>
<li>
<p>有些MOS管的源极和漏极可以互换运用, 栅极也可正可负, 灵活性比三极管好.</p>
</li>
<li>
<p>MOS管应用普遍, 可以在很小电流和很低电压下工作.</p>
</li>
<li>
<p>MOS管输入阻抗大, 低噪声, MOS管较贵, 三极管的损耗大.</p>
</li>
<li>
<p>MOS管常用来作为电源开关, 以及大电流开关电路、高频高速电路中, 三极管常用来数字电路开关控制.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>基本的门电路</p>
<p>触发器/RS触发器/D触发器/边沿性D触发器 工作原理
锁存器 工作原理</p>
<h2 id="ttl触发器"><a class="header" href="#ttl触发器">TTL触发器</a></h2>
<p>参考自: 数字电子技术基础 - 3.5.2  TTL反相器的电路结构和工作原理</p>
<p><img src="hardware/images/TTL%E5%8F%8D%E5%90%91%E5%99%A8.png" alt="" /></p>
<h3 id="分析"><a class="header" href="#分析">分析</a></h3>
<p><img src="hardware/images/TTL%E5%8F%8D%E5%90%91%E5%99%A8-T1.png" alt="" /></p>
<p>设 $V_{CC}$ 为5v, 输入信号: $V_{IH} = 3.4V$, $V_{IL} = 0.2V$. 开启电压: $V_{ON}=0.7V$.</p>
<h4 id="v_iv_il02v"><a class="header" href="#v_iv_il02v">$v_I=V_{IL}=0.2V$</a></h4>
<p>$T_1$ 的发射结必然导通. 导通后 $T_1$ 的基极电位被钳在 $v_{B1} = V_{IL} + V_{ON} = 0.9V$, $i_B = (V_{CC} - v_B) / R_1 = 1.025mA$. 根据 $T_1$ 的集电极回路, 可以计算 $T_1$ 的最大饱和电流为: $5v / 1.6k\Omega = 3.125mA$, 由于$\beta$一般在几十到几百, $3.125 / 1.025 \approx 3$远小于正常值, 因此 $T_1$ 工作在饱和状态, 所以 $v_{b2}$ 小于 $v_{b1}$, 所以 $T_2$ 截至, $v_{b5} = 0$, $T_5$ 截至. $T_2$ 截至, $r_{ce2}$ 很大, 所以 $v_{c2} \approx 5V$, $v_{b4} \approx 5V$, $T_4$ 导通, $v_e4 \approx 4.3V$, 经过D2后, $v_o \approx 4.3V - 0.7V = 3.6V$</p>
<h4 id="v_iv_ih34v"><a class="header" href="#v_iv_ih34v">$v_I=V_{IH}=3.4V$</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nanoesp32-c3-开发板"><a class="header" href="#nanoesp32-c3-开发板">nanoESP32-C3 开发板</a></h1>
<h2 id="使用-openocd-调试-esp32c3"><a class="header" href="#使用-openocd-调试-esp32c3">使用 openocd 调试 esp32c3</a></h2>
<h3 id="编译-hidapi"><a class="header" href="#编译-hidapi">编译 hidapi</a></h3>
<pre><code>编译 openocd-esp32 失败:
    configure: error: hidapi is required for the CMSIS-DAP Compliant Debugger

编译 hidapi:

git clone https://github.com/Dashlane/hidapi.git
cd hidapi
./bootstrap
./configure --enable-static --disable-shared
make clean
make
sudo make install
</code></pre>
<h3 id="编译-openocd-esp32"><a class="header" href="#编译-openocd-esp32">编译 openocd-esp32</a></h3>
<pre><code>git clone https://github.com/espressif/openocd-esp32.git
cd openocd-esp32
./bootstrap
./configure --enable-cmsis-dap
make -j
sudo make install

sudo systemctl restart udev
</code></pre>
<h2 id="burn-the-efuse"><a class="header" href="#burn-the-efuse">Burn the efuse</a></h2>
<p>the efuse JTAG_SEL_ENABLE should be burned to enable the jtag function.</p>
<pre><code>espefuse.py -p /dev/ttyACM0 burn_efuse JTAG_SEL_ENABLE
</code></pre>
<h2 id="启动-openocd"><a class="header" href="#启动-openocd">启动 openocd</a></h2>
<pre><code>设置 GPIO10 到 GND 用于选择 GPIO function 到 JTAG, 重新给开发板上电

openocd -f interface/cmsis-dap.cfg -f target/esp32c3.cfg -c &quot;adapter_khz 10000&quot;

能调试, 但有两个大问题: 1.速度特别慢,esp的日志输出需要12s，LED电平翻转需要3s 2.openocd启动后,gdb可能有5次只能成功连上1到2次 体验极差,还是打Log最方便了...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stm32笔记"><a class="header" href="#stm32笔记">STM32笔记</a></h1>
<h2 id="时钟选择"><a class="header" href="#时钟选择">时钟选择</a></h2>
<p>查询 STM32F1/F7中文参考手册, &quot;2.2 存储器组织结构&quot;, 查看使用的外设挂载在哪个总线上, 总线的速度可以通过 STM32CUBEMX 软件中查看到</p>
<p><img src="embedded/images/stm32/%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C-%E6%80%BB%E7%BA%BF.png" alt="" /></p>
<p><img src="embedded/images/stm32/stm32cubemx-clock.png" alt="" /></p>
<h2 id="windows-开发环境搭建"><a class="header" href="#windows-开发环境搭建">windows 开发环境搭建</a></h2>
<h3 id="安装软件包管理工具choco"><a class="header" href="#安装软件包管理工具choco">安装软件包管理工具choco</a></h3>
<pre><code>administrator权限打开powershell, 执行:
	Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

使用choco安装(admin权限):
	make - 构建工具
	openocd - debug server
	gcc-arm-embedded - 编译工具链

choco install make openocd gcc-arm-embedded
</code></pre>
<h3 id="安装非choco管理的软件"><a class="header" href="#安装非choco管理的软件">安装非choco管理的软件</a></h3>
<pre><code>这下面的在choco中没有找到, 需要手动安装:

	stm32cubemx:
		https://www.st.com/zh/development-tools/stm32cubemx.html
		
	stlink 驱动, 调试使用
		https://my.st.com/content/my_st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html
</code></pre>
<h3 id="使用-cmsisdap-调试-stm32"><a class="header" href="#使用-cmsisdap-调试-stm32">使用 cmsisdap 调试 stm32</a></h3>
<pre><code>创建文件 dap-stm32.cfg, 添加以下内容:

	interface cmsis-dap
	transport select swd
	source [find target/stm32f1x.cfg]

烧写程序:
    openocd -f dap-stm32.cfg -c &quot;program build/stm32f103rct6.bin 0x8000000 reset exit&quot;


用vscode调试, 安装插件: 1.c/c++ 2.cortex-debug

打开 launch.json, 新添加一项调试配置:

	{
		&quot;name&quot;: &quot;Cortex Debug&quot;,
		&quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
		&quot;executable&quot;: &quot;build/stm32f103rct6.elf&quot;,
		&quot;request&quot;: &quot;launch&quot;,
		&quot;type&quot;: &quot;cortex-debug&quot;,
		&quot;servertype&quot;: &quot;openocd&quot;,
		&quot;configFiles&quot;: [
			&quot;dap-stm32.cfg&quot;
		]
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<pre><code>https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/README

开发环境: 
    硬件: Art-pi stm32h750
    开发环境: Deepin OS
</code></pre>
<h2 id="入门"><a class="header" href="#入门">入门</a></h2>
<pre><code>环境：

    sudo apt-get install libncurses5-dev

    pip3 install --user scons 或 sudo apt-get install scons

    可选： sudo apt-get install qemu


代码：
    
    git clone https://github.com/RT-Thread/rt-thread.git

    cd rt-thread/bsp/stm32/stm32h750-artpi-h750

编译
    scons

烧写：

    openocd -f board/stm32h750b-disco.cfg

    arm-none-eabi-gdb -ex &quot;target extended-remote :3333&quot; ./rt-thread.elf

        monitor halt
        load

    telnet 127.0.0.1 4444

        load_image ./rt-thread.elf
        reset run
</code></pre>
<h2 id="更新-在线包"><a class="header" href="#更新-在线包">更新 在线包</a></h2>
<pre><code>使用 &quot;scons --menuconfig&quot; 后 会默认安装及初始化Env环境, 并在home目录下生成&quot;.env&quot;目录

执行 &quot;source ~/.env/env.sh&quot; 才可以使用 pkgs 命令

pkgs --update
</code></pre>
<h2 id="配置-wifi-tcp-通信"><a class="header" href="#配置-wifi-tcp-通信">配置 wifi tcp 通信</a></h2>
<pre><code>git clone https://github.com/RT-Thread-Studio/sdk-bsp-stm32h750-realthread-artpi.git

cd sdk-bsp-stm32h750-realthread-artpi/projects/art_pi_wifi

先创建链接：
    ln -s ../../rt-thread rt-thread
    ln -s ../../libraries libraries

就可以运行 GUI 了：
    scons --menuconfig

生成 vscode 项目：
    scons --target=vsc

编译：
    scons -j 40

烧写：
    st-flash write rtthread.bin 0x8000000

烧写后， 看串口终端有了 输出. 网络初始化后,

扫描 wifi:
    wifi scan

加入热点：
    wifi join HOT-NAME HOT-PASSWORD
</code></pre>
<h2 id="flash"><a class="header" href="#flash">flash</a></h2>
<pre><code>Flash 存储是按块组织的, 在使用时也倾向于按块访问才更加高效.

    在写入数据时, 需要先将所写位置所属的块擦除, 不管你是不是只写一个字节. 所以如果要改写Flash中的数据, 总是先将数据所属的块缓存到内存中, 然后再在内存中改写好数据后又重新写回块, 这样就不会丢失数据, 但是开销很大.

    在读数据时, 往往也是先定位块的位置, 然后在块中顺序读取, 在不同块中 间断读取数据时非常低效的.

但是: NOR Flash 读取数据时可以做到任意的寻址而不会有太大的花销, 它的读操作是接近于RAM的，而写操作依然延续了按块擦除然后再按块写的特点

正因为这些特性，Flash通常用于存储不需要频繁改动的掉电不能丢失的数据
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust嵌入式开发环境"><a class="header" href="#rust嵌入式开发环境">Rust嵌入式开发环境</a></h1>
<h2 id="vscode-开发环境-硬件-stm32f746g-disco"><a class="header" href="#vscode-开发环境-硬件-stm32f746g-disco">vscode 开发环境, 硬件: stm32f746g-disco</a></h2>
<pre><code>安装必要的工具:

    cargo install cargo-generate
    rustup target add thumbv7em-none-eabihf

    rustup component add llvm-tools-preview
    cargo install cargo-binutils

生成项目:
    cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart

    cd &lt;DIR&gt;

重命名 .cargo/config 到 .cargo/config.toml (不改也可以, 都支持, 改了有高亮显示):

    [build]
    target = &quot;thumbv7em-none-eabihf&quot;     # Cortex-M4F and Cortex-M7F (with FPU)

修改 memory.x 中的 FLASH 和 RAM 的源地址及大小:
    FLASH : ORIGIN = 0x08000000, LENGTH = 1M
    RAM : ORIGIN = 0x20000000, LENGTH = 256K

更新一下 Cargo.toml 中依赖的版本.

编译:
    cargo build

查看大小
    cargo size --bin app
    cargo size --bin app -- -A

查看二进制信息:
    cargo readobj --bin app -- -file-headers

反汇编二进制文件:
    cargo objdump --bin app --release -- --disassemble --no-show-raw-insn --print-imm-hex

调试, 在launch文件中添加:
    {
		/* Configuration for the STM32F303 Discovery board */
		&quot;type&quot;: &quot;cortex-debug&quot;,
		&quot;request&quot;: &quot;launch&quot;,
		&quot;name&quot;: &quot;Debug (OpenOCD)&quot;,
		&quot;servertype&quot;: &quot;openocd&quot;,
		&quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
		&quot;preLaunchTask&quot;: &quot;Cargo Build (debug)&quot;,
		&quot;runToMain&quot;: true,
		&quot;executable&quot;: &quot;./target/thumbv7em-none-eabihf/debug/app&quot;,
		&quot;configFiles&quot;: [&quot;interface/stlink.cfg&quot;, &quot;board/stm32f746g-disco.cfg&quot;],
	}
</code></pre>
<h2 id="优化"><a class="header" href="#优化">优化</a></h2>
<p>官方文档写的很清晰</p>
<p><a href="https://docs.rust-embedded.org/book/unsorted/speed-vs-size.html">The Embedded Rust Book - Optimizations: the speed size tradeoff</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c语言"><a class="header" href="#c语言">C语言</a></h1>
<h2 id="编译过程"><a class="header" href="#编译过程">编译过程</a></h2>
<pre><code>预处理: 展开头文件及宏定义
	gcc -E -I./inc test.c -o test.i
	cpp test.c -I./inc -o test.i

编译: 将预处理的代码翻译成汇编代码
	gcc -S -I./inc test.c -o test.s

汇编: 将汇编代码翻译成机器码, 这一步生成二进制格式的目标文件
	as test.s -o test.o

链接: 将目标文件和库文件链接成最后的可执行程序
	ld -o test.out test.o inc/mymath.o ...libraries...
</code></pre>
<h2 id="内存布局"><a class="header" href="#内存布局">内存布局</a></h2>
<pre><code>栈区

	局部变量, 编译器在编译时已经确定了栈的大小


堆区

	malloc分配的内存, 程序员自己控制 分配与释放


数据区

	全局区(静态区)
		如果已初始化, 放在DATA段
		如果未初始化, 放在BSS段, 这里只保存必要的大小信息, 不占用可执行程序的大小, 加载程序时分配内存

	常量区
		常量字面量


代码区

	函数定义
</code></pre>
<h2 id="大小端-位域"><a class="header" href="#大小端-位域">大小端 位域</a></h2>
<pre><code>大小端:
    intel芯片用的是小端, 就是内存是递增的, 数据是按照字节存放的, 低位数据放在低地址上, 不符合人类的阅读顺序, 比如: 对int类型数据 它的数据是: b3 b2 b1 b0, 内存从低到高: b0 b1 b2 b3
</code></pre>
<h2 id="结构体对齐"><a class="header" href="#结构体对齐">结构体对齐</a></h2>
<ol>
<li>
<p>第一个成员的偏移量为0</p>
</li>
<li>
<p>其它成员的偏移量是其对齐数的整数倍</p>
</li>
<li>
<p>结构体的大小为最大对齐数的整数倍</p>
<p>例子：
struct One {
char a;
double b;
short c;
int d;
char e;
};
规则1： a的偏移量是0
规则2：
由于b的对齐数是8,所以1个字节补7个字节，b的偏移量为 0 + 1 + 7 = 8
由于c的对齐数是2,c前面的长度是  8 + 8 = 16, 是2的倍数， 所以c的偏移量是 16
由于d的对齐数是4,d前面的长度是 16 + 2 = 18, 不是4的倍数， 补2个字节， d的偏移量是 18 + 2 = 20
由于e的对齐数是1,e前面的长度是 20 + 4 = 24, 是1的倍数, d的偏移量就是 24
整体的大小为 24 + 1 = 25
规则3：
由于25不是最大对齐数的整数倍, 所以补7个字节, 为32</p>
<p>另外:</p>
<pre><code> 如果使用了 #pragma pack(4) 这个宏可以改变最大对齐数, 这意味着比如double的对齐数就是4.
 也可以使用: __attribute__((__aligned__(4)))

 #pragma pack(4)

 struct One {
 	char a;
 	double b;
 	short c;
 	int d;
 	char e;
 };

 规则1： a的偏移量是0
 规则2：
 	由于b的对齐数是4,所以1个字节补3个字节，b的偏移量为 0 + 1 + 3 = 4
 	由于c的对齐数是2,c前面的长度是  4 + 8 = 12, 是2的倍数， 所以c的偏移量是 12
 	由于d的对齐数是4,d前面的长度是 12 + 2 = 14, 不是4的倍数， 补2个字节， d的偏移量是 14 + 2 = 16
 	由于e的对齐数是1,e前面的长度是 16 + 4 = 20, 是1的倍数, d的偏移量就是 20
 	整体的大小为 20 + 1 = 21
 规则3：
 	由于21不是最大对齐数的整数倍, 所以补3个字节, 为24
</code></pre>
</li>
</ol>
<h2 id="gcc中常用属性"><a class="header" href="#gcc中常用属性">gcc中常用属性</a></h2>
<p>用于设置编译器的一些特殊行为</p>
<pre><code>设置对齐字节数:
	__attribute__((__aligned__(4)))

取消优化对齐, 按照实际字节数存储
	__attribute__((packed))

将函数或数据放到特定的代码段:
	__attribute__((section(&quot;section-name&quot;)))

阻止函数内联:
	__attribute__((noinline))

让函数总是内联:
	__attribute__((__always_inline__))

设置特定函数的优化级别， O0,O1,O2,O3:
	__attribute__((optmize(&quot;Ox&quot;)))
</code></pre>
<h2 id="gcc-优化"><a class="header" href="#gcc-优化">gcc 优化</a></h2>
<h3 id="优化级别"><a class="header" href="#优化级别">优化级别</a></h3>
<pre><code>O0,O1,O2,O3,Os
</code></pre>
<h3 id="优化方法"><a class="header" href="#优化方法">优化方法</a></h3>
<p>通过给gcc参数:</p>
<pre><code>gcc -O2 ...
</code></pre>
<p>通过代码:</p>
<pre><code>给这行代码以下的代码设置优化级别:
	#pragma GCC optimize (&quot;O3&quot;)

给特定函数设置属性:
	__attribute__((optmize(&quot;O3&quot;)))
</code></pre>
<h2 id="main函数之前发生的事"><a class="header" href="#main函数之前发生的事">main函数之前发生的事</a></h2>
<p>大概是:</p>
<ol>
<li>设置栈帧</li>
<li>设置bss区域数据为0</li>
<li>如果需要, 执行 hardware/software init</li>
<li>配置参数</li>
<li>调用main</li>
<li>执行exit.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb-用法"><a class="header" href="#gdb-用法">GDB 用法</a></h1>
<p>参考: <a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/part13.html">100个gdb小技巧</a></p>
<h2 id="gdb-命令行中调试"><a class="header" href="#gdb-命令行中调试">GDB 命令行中调试</a></h2>
<pre><code>连接stm32设备:
    openocd -f interface/stlink.cfg -f board/stm32f746g-disco.cfg,

运行GDB:
    arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/app

连接 openocd server:
    target remote :3333

加载程序:
    load

显示内存:
    x/2xw 0x60000000

设置寄存器的值:
    set $pc=0x60011691
    set $sp=0x6004e5a0

继续:
    c

显示变量:
    info local VARIABLE_NAME
</code></pre>
<h2 id="gdb命令的参数"><a class="header" href="#gdb命令的参数">gdb命令的参数</a></h2>
<pre><code>设置
--command=FILE
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpio和afio"><a class="header" href="#gpio和afio">GPIO和AFIO</a></h1>
<p>参考: STM32F10xxx参考手册.pdf</p>
<h2 id="gpio-功能描述"><a class="header" href="#gpio-功能描述">GPIO 功能描述</a></h2>
<p>GPIO 配置寄存器
GPIO 数据寄存器
GPIO 置位/复位寄存器
GPIO 锁定寄存器</p>
<p>GPIO的多种工作模式</p>
<ul>
<li>输入浮空</li>
<li>输入上拉</li>
<li>输入下拉</li>
<li>模拟输入</li>
<li>开漏输出</li>
<li>推挽式输出</li>
<li>推挽式复用功能</li>
<li>开漏复用功能</li>
</ul>
<h3 id="gpio-基本结构"><a class="header" href="#gpio-基本结构">GPIO 基本结构</a></h3>
<p>参考: <a href="https://zhuanlan.zhihu.com/p/67412159">STM32入门系列-GPIO结构</a></p>
<p><img src="embedded/images/GPIO%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="" /></p>
<p>理解好了GPIO的内部结构, 那么GPIO的各种模式将非常清楚. 分析图中标注的数字部分:</p>
<ol>
<li>保护二极管</li>
</ol>
<p>加这两个保护二极管可以防止不正常电压进入芯片导致芯片烧毁.</p>
<p>当引脚电压大于 $V_{DD}$ 时, 上方的保护二极管导通, 输入被钳位到 $V_{DD}$, 当引脚电压低于 $V_{SS}$ 时, 下方的保护二极管导通, 输入被钳位到 $V_{SS}$.</p>
<p>尽管GPIO内部有这样的保护, 但是如果将引脚直连大功率器件, 要么器件不工作, 要么芯片烧毁. 如果要驱动大功率器件, 必须加 大功率及隔离电路驱动. 所以说GPIO引脚是做控制的, 不是做驱动使用的.</p>
<p><strong>问题: 来了一个高于 $V_{DD}$ 的电压时, 输入是如何被钳位到 $V_{DD}$? 这个过程是怎样的?</strong></p>
<p>答: 根据二极管的伏安特性, 在二极管导通后, 即使电流的指数级变化也无法引起电压的快速变化, 电压会稳定在 0.6~0.8V.</p>
<ol start="2">
<li>上下拉电阻</li>
</ol>
<p>上拉电阻和下拉电阻旁都有一个开关, 通过配置这个开关, 可以控制开启上拉电阻或下拉电阻, 间接地控制输入引脚的默认电平, 这可以消除不确定状态的影响. 当开启上拉时 默认输入是高电平, 当开启下拉时 默认输入是低电平.</p>
<p>如果上拉和下拉都关断, 我们称这为浮空模式, 一旦配置成这种模式, 引脚的初始电压是不确定的, 如果用万用表量一下此模式下引脚的电平会发现只有1点几伏, 而且还不时改变.</p>
<p><code>STM32内部的上拉是一个弱上拉, 即此上拉电阻输出的电流很小, 如果想输出较大的电流, 就需要外接上拉电阻了.</code></p>
<p>问题: 图中, 读出那个部分是什么样的电路读取传进去的0或1的?</p>
<ol start="3">
<li>PMOS和NMOS</li>
</ol>
<p>P-MOS和N-MOS管组成的单元电路, 这让GPIO引脚具有了推挽和开漏两种输出模式. 在推挽输出模式中,</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ws2812-使用笔记"><a class="header" href="#ws2812-使用笔记">ws2812 使用笔记</a></h1>
<h2 id="芯片手册"><a class="header" href="#芯片手册">芯片手册</a></h2>
<p><a href="https://item.szlcsc.com/235391.html">立创商城 -- ws2813 芯片手册 --  由于ws2813手册是中文的,且兼容ws2812</a></p>
<p>数据发送速度可达800Kbps</p>
<p>数据协议采用单线归零码的通讯方式，像素点在上电复位以后，DIN端接受从控制器传输过来的数据，首先
送过来的24bit数据被第一个像素点提取后，送到像素点内部的数据锁存器，剩余的数据经过内部整形处理电路整
形放大后通过DO端口开始转发输出给下一个级联的像素点，每经过一个像素点的传输，信号减少24bit。</p>
<h3 id="数据传输时间"><a class="header" href="#数据传输时间">数据传输时间</a></h3>
<p><img src="embedded/%E4%BC%A0%E6%84%9F%E5%99%A8/images/ws2812/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4.png" alt="" /></p>
<h3 id="时序波形"><a class="header" href="#时序波形">时序波形</a></h3>
<p><img src="embedded/%E4%BC%A0%E6%84%9F%E5%99%A8/images/ws2812/%E6%97%B6%E5%BA%8F%E6%B3%A2%E5%BD%A2.png" alt="" /></p>
<h3 id="数据传输方法"><a class="header" href="#数据传输方法">数据传输方法</a></h3>
<p><img src="embedded/%E4%BC%A0%E6%84%9F%E5%99%A8/images/ws2812/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E6%B3%95.png" alt="" /></p>
<h3 id="24bit-数据结构"><a class="header" href="#24bit-数据结构">24bit 数据结构</a></h3>
<p><img src="embedded/%E4%BC%A0%E6%84%9F%E5%99%A8/images/ws2812/24bit%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="" /></p>
<h3 id="典型应用电路图"><a class="header" href="#典型应用电路图">典型应用电路图</a></h3>
<p><img src="embedded/%E4%BC%A0%E6%84%9F%E5%99%A8/images/ws2812/%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E7%94%B5%E8%B7%AF.png" alt="" /></p>
<h2 id="stm32f7-控制-ws2812"><a class="header" href="#stm32f7-控制-ws2812">STM32F7 控制 ws2812</a></h2>
<h3 id="pwm--dma"><a class="header" href="#pwm--dma">PWM + DMA</a></h3>
<p>数据发送速度是800kHz, 表示 ws2812 的输入频率为800kHz, 我用的是 TIM3 PWM CH1, 使用内部时钟, 即TIM3所属总线APB1的CLOCK, 速度为108mHz, 为了得到800kHz, 108mHz = 0.8mHz * 5 * 27, 设置 TIM3 的预分频 prescaler 为 5-1, 设置 自动重载值 ARR 为 27-1, 所以 PWM 的 PULSE的取值范围是 0~26, 根据 ws2812 的&quot;数据传输时间&quot;, 可以计算得: 0码的占空比大约为 $220 / (220 + 580)\approx0.275$, 1码的占空比大约为 $580 / (220 + 580)\approx0.725$, 所以设置 0码的 Pulse 为 $0.275 * 27 \approx 7$, 1码的 Pulse 为 19.</p>
<pre><code>PWM参数:

    CH Polarity: 空闲时刻的电平状态
        &quot;High&quot; 表示空闲为高, 所以有效电平为&quot;Low&quot;, 即低电平有效
        &quot;Low&quot; 表示空闲为低, 所以有效电平为&quot;High&quot;, 即高电平有效

        输出比较极性的指的是你在比较匹配之后输出口输出的极性

    Mode:
        PWM Mode 1, CNT&lt;CRRx为有效电平
        PWM Mode 2, CNT&gt;CRRx为有效电平

    当向上递增时, 设置 CH Polarity 为 &quot;High&quot;, 选择 &quot;PWM Mode 1&quot;, 则: High为有效电平, CNT &lt; CRRx 时 为High

配置好了以后别忘了, 启动PWM:
    HAL_TIM_PWM_Start(&amp;htimX, TIM_CHANNEL_X);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>官方文档</p>
<p>https://docs.lvgl.io/master/overview/index.html</p>
<h2 id="simulator-on-pc"><a class="header" href="#simulator-on-pc">simulator on PC</a></h2>
<p>模拟器是为了方便在电脑端开发并验证效果</p>
<ol>
<li>
<p>下载 Eclipse CDT IDE 环境</p>
<p>https://github.com/gnu-mcu-eclipse/org.eclipse.epp.packages/releases/</p>
</li>
<li>
<p>安装 SDL2</p>
<p>On Linux:</p>
<pre><code> sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential libsdl2-dev
</code></pre>
</li>
<li>
<p>下载 eclipse's simulator project:</p>
<p>git clone --recursive https://github.com/lvgl/lv_sim_eclipse_sdl.git</p>
</li>
<li>
<p>使用cmake编译这个项目</p>
<p>cd lv_sim_eclipse_sdl
mkdir build
cd build
cmake ..
make -j</p>
</li>
<li>
<p>打开 eclipse CDT, 导入 simulator project</p>
</li>
<li>
<p>在 &quot;Run Configurations...&quot; 配置编译 &quot;C/C++ Application&quot;</p>
<p><img src="embedded/lvgl/2022-02-26-13-01-10.png" alt="" /></p>
<p>编译命令是:</p>
<pre><code> make -j -C ${workspace_project_locations}/build
</code></pre>
<p>这样就可以编译并运行了</p>
</li>
</ol>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<pre><code>f746 disco:

    git clone --recursive https://github.com/lvgl/lv-port_stm32f746_disco.git
</code></pre>
<h2 id="lvgl"><a class="header" href="#lvgl">lvgl</a></h2>
<p>设置 宽和高.</p>
<p>lv_disp_drv_t disp_drv;
disp_drv.hor_res = LV_HOR_RES_MAX;
disp_drv.ver_res = LV_VER_RES_MAX;</p>
<p>有两种方式设置旋转屏幕:</p>
<ol>
<li>
<p>lvgl soft 实现, 这耗时较大</p>
<p>disp_drv.sw_rotate = 1;
disp_drv.rotated = LV_DISP_ROT_90;</p>
</li>
<li>
<p>硬件实现, 速度快, 消耗小</p>
<p>disp_drv.rotated = LV_DISP_ROT_90; // 这种情况, 这个只用来 确定 分辨率</p>
<p>并设置 CONFIG_LV_DISPLAY_ORIENTATION</p>
<p>硬件调用:
st7735s_set_orientation(uint8_t orientation)
可能需要 设置屏幕 X.Y对调, X方向从上到下, Y方向从下到上 等等</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>RX 590 显卡驱动， linux版下载:</p>
<p><a href="https://www.amd.com/zh-hans/support/">点击链接</a></p>
<p><img src="design/images/blender/RX590%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.png" alt="image-20210423080516521" /></p>
<p>https://amdgpu-install.readthedocs.io/en/latest/install-script.html</p>
<p>我用的是</p>
<p>./amdgpu-pro-install -y --opencl=pal,legacy</p>
<h2 id="安装-amd-显卡驱动"><a class="header" href="#安装-amd-显卡驱动">安装 AMD 显卡驱动</a></h2>
<pre><code class="language-sh"># Install the AMD Drivers
apt install firmware-linux firmware-linux-nonfree libdrm-amdgpu1 xserver-xorg-video-amdgpu

# Install Vulkan
apt install mesa-vulkan-drivers libvulkan1 vulkan-tools vulkan-utils vulkan-validationlayers

# Install OpenCL
apt install mesa-opencl-icd

apt install ocl-icd-* opencl-headers

apt install clinfo

clinfo

</code></pre>
<h2 id="查看显卡"><a class="header" href="#查看显卡">查看显卡</a></h2>
<p>lspci -nn | grep VGA</p>
<p>mkdir -p ~/.local/share/deepin/themes/deepin/dark</p>
<p>vim titlebar.ini:</p>
<pre><code>[Active]
height=24

[Inactive]
height=24
</code></pre>
<p>apt-get install firmware-amd-graphics libgl1-mesa-dri libglx-mesa0 mesa-vulkan-drivers xserver-xorg-video-all</p>
<p>dpkg-deb: 错误: 粘贴 子进程被信号(断开的管道) 终止了
sudo dpkg -i --force-overwrite /var/cache/apt/archives/firmware-amd-graphics_20190114-2_all.deb</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust后端开发"><a class="header" href="#rust后端开发">Rust后端开发</a></h1>
<p>一个比较基础的学习项目</p>
<p>https://github.com/noxue/banquet</p>
<p>一个方便写接口的测试工具</p>
<p>https://www.apipost.cn/download.html</p>
<p><img src="program/rust/rust%E5%90%8E%E7%AB%AF/2022-02-27-00-35-53.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-一个游戏引擎"><a class="header" href="#bevy-一个游戏引擎">bevy 一个游戏引擎</a></h1>
<h2 id="code"><a class="header" href="#code">code</a></h2>
<pre><code>git clone https://github.com/bevyengine/bevy
cargo run --example breakout
</code></pre>
<h2 id="state"><a class="header" href="#state">state</a></h2>
<p>主要的数据结构:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 用于操作游戏state, 比如 设置/替换/退出/进入 state
enum ScheduledOperation&lt;T: Component + Clone + Eq&gt; {
    Set(T),
    Replace(T),
    Pop,
    Push(T),
}

// 状态切换 如果是 PreStartup 则会进入 Startup
// 后面几个是 (leaving, entering), 表示从 leaving状态 切换到 entering状态
enum StateTransition&lt;T: Component + Clone + Eq&gt; {
    PreStartup,
    Startup,
    // The parameter order is always (leaving, entering)
    ExitingToResume(T, T),
    ExitingFull(T, T),
    Entering(T, T),
    Resuming(T, T),
    Pausing(T, T),
}
<span class="boring">}
</span></code></pre></pre>
<p>初始化状态, 并添加特定状态下要执行的系统集:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 添加一个 state, 即此处的GameState, 设置初始状态为 Playing
// 并添加一个systemset, 设置 run_criteria 为 state_cleaner
App::build()
    .add_state(GameState::Playing)
    .add_system_set(SystemSet::on_enter(GameState::Playing).with_system(setup.system()))

// 这个函数主要用于处理 state.scheduled 和 state.transition
fn state_cleaner&lt;T: Component + Clone + Eq&gt;(
    mut state: ResMut&lt;State&lt;T&gt;&gt;,
    mut prep_exit: Local&lt;bool&gt;,
)
{
    match state.scheduled.take() {

        Some(ScheduledOperation::Set(next)) =&gt; {
            state.transition = Some(StateTransition::ExitingFull(
                state.stack.last().unwrap().clone(),
                next,
            ));
        }
        Some(ScheduledOperation::Replace(next)) =&gt; { ... }
        Some(ScheduledOperation::Push(next)) =&gt; { ... }
        Some(ScheduledOperation::Pop) =&gt; { ... }
        None =&gt; match state.transition.take() {
            Some(StateTransition::ExitingFull(p, n)) =&gt; { ... }
            Some(StateTransition::Pausing(p, n)) =&gt; { ... }
            Some(StateTransition::ExitingToResume(p, n)) =&gt; { ... }
            Some(StateTransition::PreStartup) =&gt; { ... }
        }
}

// 当执行 state.set(GameState::GameOver), 会设置 scheduled 的值, 就会改变 state.transition 的值, 后面特定的system_set就启动
pub fn set(&amp;mut self, state: T) -&gt; Result&lt;(), StateError&gt; {
    if self.stack.last().unwrap() == &amp;state {
        return Err(StateError::AlreadyInState);
    }

    if self.scheduled.is_some() {
        return Err(StateError::StateAlreadyQueued);
    }

    self.scheduled = Some(ScheduledOperation::Set(state));
    Ok(())
}

<span class="boring">}
</span></code></pre></pre>
<p>这会添加两个systemset, 其中的system会按照添加的顺序添加到, 在stage中运行时, 这些systems会自上而下运行</p>
<p><code>.add_state(GameState::Playing)</code> 这会初始化状态并放入全局组件中, 会添加一个 systemset, 并带有 state_cleaner 的 run_criteria, 用于处理 判断状态是否满足预期, 是否应该运行.</p>
<p>当执行 <code>SystemSet::on_enter</code>, <code>SystemSet::on_exit</code>, <code>SystemSet::on_update</code>时, 会添加不同的run_criteria, 用于判断特定的状态发生时是否应该执行. 比如:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn on_update(s: T) -&gt; RunCriteriaDescriptor {
    (|state: Res&lt;State&lt;T&gt;&gt;, pred: Local&lt;Option&lt;T&gt;&gt;| {
        // 当判断当前的state是预期的状态时, 同时事务还未开始时, return true, 表示执行
        state.stack.last().unwrap() == pred.as_ref().unwrap() &amp;&amp; state.transition.is_none()
    })
    .system()
    .config(|(_, pred)| *pred = Some(Some(s.clone()))) // 这会把传入的状态即期望的状态保存到这个 system 的第二个参数, 即pred
    .chain(should_run_adapter::&lt;T&gt;.system())
    .after(DriverLabel::of::&lt;T&gt;())
    .label_discard_if_duplicate(StateCallback::Update.into_label(s))
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 初始化状态
Self {
    stack: vec![initial],
    transition: Some(StateTransition::PreStartup),
    scheduled: None,
    end_next_loop: false,
}

<span class="boring">}
</span></code></pre></pre>
<p>当 systemset 第一次运行时, stage.scheduled 为 None, 则设置 state.transition = Some(StateTransition::Startup), 表示执行Startup事务. 并 设置 prep_exit 为 true, 表示第一次运行完成.</p>
<p>先有 scheduled 再根据 scheduled 判断 transaction</p>
<p>当执行 <code>state.set(GameState::GameOver)</code> 时, 会验证: 1.当前的 stage.stack 的最后一项不能是要设置的状态 2.stage.scheduled 需要是空的, 然后更新状态: <code>self.scheduled = Some(ScheduledOperation::Set(state))</code></p>
<h2 id="20220115"><a class="header" href="#20220115">2022.01.15</a></h2>
<pre><code>添加 WindowPlugin 插件
    会 添加大量的窗口初始化事件:
        WindowResized
        CreateWindow
        WindowCreated
        WindowCloseRequested
        CloseWindow
        CursorMoved
        ...

添加 WinitPlugin 插件
    初始化 winit 环境, 创建窗口, 并设置 runner(处理事件的loop)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web"><a class="header" href="#web">web</a></h1>
<h2 id="js-对象展开运算符"><a class="header" href="#js-对象展开运算符">js 对象展开运算符</a></h2>
<pre><code>state.obj = { ...state.obj, newProp: 123 }
</code></pre>
<h2 id="typescript-模块解析"><a class="header" href="#typescript-模块解析">typescript 模块解析</a></h2>
<p><a href="https://www.tslang.cn/docs/handbook/module-resolution.html">typescript 模块解析</a></p>
<h2 id="使用-nvm-管理-nodejs"><a class="header" href="#使用-nvm-管理-nodejs">使用 nvm 管理 nodejs</a></h2>
<pre><code>网址: https://github.com/nvm-sh/nvm

curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash
nvm install --lts

npm config set registry https://registry.npm.taobao.org
npm config get registry

npm install -g yarn
yarn config set registry 'https://registry.npm.taobao.org'
</code></pre>
<h2 id="生成tsconfigjson文件"><a class="header" href="#生成tsconfigjson文件">生成tsconfig.json文件</a></h2>
<pre><code>yarn add -D typescript
yarn tsc --init
</code></pre>
<h2 id="使用npm安装cordova-执行cordova-create报错"><a class="header" href="#使用npm安装cordova-执行cordova-create报错">使用npm安装cordova, 执行cordova create报错</a></h2>
<pre><code>npm ERR! not a package.........@cordova-app-hello-world\index.js
卸载cordova, 使用yarm重新安装即可:
    sudo npm uninstall -g cordova
    sudo npm install -g yarn
    sudo yarn config set registry https://registry.npm.taobao.org
    sudo yarn global add cordova
</code></pre>
<h2 id="packagejson-版本约定号"><a class="header" href="#packagejson-版本约定号">package.json 版本约定号</a></h2>
<pre><code>~version

大概匹配某个版本

如果minor版本号指定了, 那么minor版本号不变, 而patch版本号任意

如果minor和patch版本号未指定, 那么minor和patch版本号任意

如：~1.1.2, 表示&gt;=1.1.2 &lt;1.2.0, 可以是1.1.2, 1.1.3, 1.1.4, ....., 1.1.n

如：~1.1, 表示&gt;=1.1.0 &lt;1.2.0, 可以是同上

如：~1, 表示&gt;=1.0.0 &lt;2.0.0, 可以是1.0.0, 1.0.1, 1.0.2, ....., 1.0.n, 1.1.n, 1.2.n, ....., 1.n.n


^version

兼容某个版本

版本号中最左边的非0数字的右侧可以任意

如果缺少某个版本号, 则这个版本号的位置可以任意

如：^1.1.2 , 表示&gt;=1.1.2 &lt;2.0.0, 可以是1.1.2, 1.1.3, ....., 1.1.n, 1.2.n, ....., 1.n.n

如：^0.2.3 , 表示&gt;=0.2.3 &lt;0.3.0, 可以是0.2.3, 0.2.4, ....., 0.2.n

如：^0.0, 表示 &gt;=0.0.0 &lt;0.1.0, 可以是0.0.0, 0.0.1, ....., 0.0.n
</code></pre>
<h2 id="jquery"><a class="header" href="#jquery">jquery</a></h2>
<pre><code>prop attr的区别：
    在这里, 我们可以将attribute理解为“特性”, property理解为为“属性”从而来区分俩者的差异。
    举个例子, option当做一个对象：
    var option = {
        selected:false,
        disabled:false,
        attributes:[],
        ...
    }
    attributes是自定义的键值对, property是对象自身的属性:selected、disabled、attributes...
</code></pre>
<p>##　报错:sh: 1: tsc: not found</p>
<pre><code>需要安装typescript, 执行:sudo npm install -g typescript
</code></pre>
<h2 id="chrome插件开发"><a class="header" href="#chrome插件开发">chrome插件开发</a></h2>
<pre><code>[an example](https://developer.chrome.com/extensions/getstarted/ &quot;略略&quot;)
</code></pre>
<h2 id="div层调整zindex属性无效原因分析及解决方法"><a class="header" href="#div层调整zindex属性无效原因分析及解决方法">div层调整zindex属性无效原因分析及解决方法</a></h2>
<pre><code>这种情况发生的条件有三个:

1、父标签 position属性为relative

2、问题标签无position属性（不包括static)

3、问题标签含有浮动(float)属性

eg:z-index层级不起作用, 浮动会让z-index失效


子元素浮动,父div没有自适应
clear:both 不管用?
给父元素添加: overflow:hidden

一个div内的多个同级div, 同级的div在同一行, 怎么保证它们高度一致?
margin-bottom


1,在当前窗口中跳转:
    window.location.href('url') 存在兼容问题,火狐不支持,可以使用 window.location='url';

    history.back();返回

2,学会使用data*属性,这是属于html5的标签属性, 传递参数时可以在路径中加上?key1=value1&amp;key2=value2的形式

3,onbar事件
    使用taglib prefix =&quot;c&quot;, 循环

4,使用锚点:
    &lt;a name=&quot;anchor1&quot;/&gt;.........&lt;a target=&quot;#anchor1&quot;/&gt;


软件 Artisteer firework ps 美图秀秀

textContent与innerHTNL的区别:textContent返回元素及其后代的文本内容,而innerHTML则返回HTML

ie和火狐遍历子节点chileNodes的区别:ie没有空格,火狐带空格

ul中的li居中:li的默认display为block,设置li为inline


对于浮动元素的高度为0,可以通过设置:如下:
    ul:after {
    content: &quot;&quot;;
    display: table;
    clear: both;
    }


动画滚动:
$msg_container.animate({ scrollTop: $msg_container.prop(&quot;scrollHeight&quot;) });


/**
* 禁用右键菜单
*/
document.oncontextmenu = function(){
    event.returnValue = false;
};

/**
* 禁用选中功能
*/
document.onselectstart = function(){
    event.returnValue = false;
};

/**
* 禁用复制功能
*/
document.oncopy = function(){
    event.returnValue = false;
};

/**
* 禁用鼠标的左右键
*/
document.onmousedown = function(){
    if(event.which==1){//鼠标左键
        return false;
    }

    if(event.which==3){//鼠标右键
        return false;
    }
};

/**
* 获取键盘上的输入值
*/
document.onkeydown = function(){
    console.info(event.which);
    if(event.which==13){
        console.info(&quot;回车键&quot;);
    }
};
</code></pre>
<h2 id="设置页面居中"><a class="header" href="#设置页面居中">设置页面居中</a></h2>
<pre><code>background:url(\${sb.imageUrl }) no-repeat; background-size:150px 100px; background-position: center;

div居中:
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%); // 偏移自身的50%
</code></pre>
<h2 id="指定宽度-剩余铺满"><a class="header" href="#指定宽度-剩余铺满">指定宽度 剩余铺满</a></h2>
<pre><code>&lt;div style=&quot;display: flex;&quot;&gt;
    &lt;div style=&quot;flex-grow: 1;&quot;&gt;&lt;/div&gt;
    &lt;div style=&quot;width: 300px;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="npm"><a class="header" href="#npm">npm</a></h2>
<pre><code>配置文件 $HOME/.npmrc
查看所有配置:
    npm config ls -l
</code></pre>
<h2 id="yarn"><a class="header" href="#yarn">yarn</a></h2>
<pre><code>yarn config list
</code></pre>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<pre><code>yarn global add npm-check
npm-check -u
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="electronneon"><a class="header" href="#electronneon">electron+neon</a></h1>
<h2 id="neon"><a class="header" href="#neon">neon</a></h2>
<p><a href="https://neon-bindings.com/docs/getting-started/">getting-started</a></p>
<h3 id="install-the-neon-cli"><a class="header" href="#install-the-neon-cli">Install the Neon CLI</a></h3>
<pre><code>Unix 依赖:
    Python 2.7 (Python 3 is not supported)
    make
    A proper C/C++ compiler toolchain, like GCC
安装:
    npm install --global neon-cli

验证:
    neon version
</code></pre>
<h3 id="实践neon"><a class="header" href="#实践neon">实践neon</a></h3>
<pre><code># 创建项目
neon new thread-count

# 编译
cd thread-count
neon build --release

# 验证
node
&gt; require('.')
hello node
{}
&gt;

# 清理
neon clean
</code></pre>
<h2 id="打包"><a class="header" href="#打包">打包</a></h2>
<p><del>方法1:</del></p>
<p><del>npm install electron-packager -g</del><br />
<del>electron-packager .</del></p>
<p>方法2:</p>
<p><a href="https://www.electron.build/">electron-builder</a></p>
<h2 id="使用-vue"><a class="header" href="#使用-vue">使用 vue</a></h2>
<pre><code>npm install -g @vue/cli
</code></pre>
<h2 id="rustneonelectron"><a class="header" href="#rustneonelectron">rust+neon+electron</a></h2>
<pre><code>新建:
    neon new rust-api
    cd rust-api
    npm link

添加一个 electron basic
git clone https://github.com/electron/electron-quick-start
cd electron-quick-start

npm install rust-api
npm install electron-build-env neon-cli --save-dev

添加:
&quot;scripts&quot;: {
    &quot;run&quot;: &quot;npm run build &amp;&amp; npm run start&quot;,
    &quot;start&quot;: &quot;electron .&quot;,
    &quot;build&quot;: &quot;electron-build-env neon build rust-api&quot;,
    &quot;release&quot;: &quot;electron-build-env neon build rust-api --release&quot;
}

    ps: 注意这里的&quot;build&quot;参数: rust-api

npm run
</code></pre>
<h2 id="electron-vue"><a class="header" href="#electron-vue">electron vue</a></h2>
<p><a href="https://github.com/SimulatedGREG/electron-vue">electron-vue</a></p>
<pre><code>添加vue-cli:
    npm install -g vue-cli

使用vue-cli创建新项目:
    vue init simulatedgreg/electron-vue electron-app

Error: Unable to install `vue-devtools`
解决:
    yarn add vue-devtools --dev
    编辑 src/main/index.dev.js:

    import { app, BrowserWindow } from &quot;electron&quot;;

    // Install `vue-devtools`
    app.on(&quot;ready&quot;, async () =&gt; {
        // let installExtension = require('electron-devtools-installer')
        // installExtension.default(installExtension.VUEJS_DEVTOOLS)
        //   .then(() =&gt; {})
        //   .catch(err =&gt; {
        //     console.log('Unable to install `vue-devtools`: \n', err)
        //   })
        await new BrowserWindow.addDevToolsExtension(
            &quot;node_modules/vue-devtools/vender&quot;
        );
    });

运行:
    npm run dev
</code></pre>
<h2 id="element-ui"><a class="header" href="#element-ui">element-ui</a></h2>
<p><a href="https://element.eleme.cn/#/zh-CN/component/quickstart">element-ui</a></p>
<h2 id="mockjs--axios-很香"><a class="header" href="#mockjs--axios-很香">mockjs + axios 很香</a></h2>
<p><a href="https://www.cnblogs.com/steamed-twisted-roll/p/10823871.html">vue项目中使用mockjs+axios模拟后台数据返回</a></p>
<h2 id="vue3-webpack"><a class="header" href="#vue3-webpack">vue3 webpack</a></h2>
<p><a href="https://github.com/nofacer/vue3-electron">Vue3+Electron整合方式</a></p>
<pre><code>npm init -y

npm install -D webpack webpack-cli
npm install -D vue@next vue-loader@next @vue@compiler-sfc

npm install -D style-loader sass-loader node-sass css-loader

npm install -D url-loader

过程主要时:
    在 webpack config 中配置怎么解析vue文件,scss文件,scss样式,require路径,
    解析 entry 中指定的文件, output 指定了 输出的文件, 这就是一个打包的过程
</code></pre>
<p>webpack.config.js配置:</p>
<pre><code class="language-javascript">    const path = require('path')
    const { VueLoaderPlugin } = require('vue-loader')

    module.exports = {
        entry: './app.js',
        output: {
            filename: 'bundle.js',
            path: path.resolve(__dirname, 'dist')
        },
        module: {
            rules: [
                {
                    test: /\.vue$/,
                    loader: 'vue-loader'
                },
                // 普通的 `.scss` 文件和 `*.vue` 文件中的
                // `&lt;style lang=&quot;scss&quot;&gt;` 块都应用它
                {
                    test: /\.scss$/,
                    use: [
                        'style-loader',
                        'css-loader',
                        'sass-loader'
                    ]
                },
                // 图片加载, base64数据, 如: &lt;img :src=&quot;require('@/img/vue_logo.png').default&quot;&gt;
                {
                    test: /\.(png|jpg|gif)$/i,
                    use: [
                        {
                            loader: 'url-loader',
                            options: {
                                limit: 8192,
                            },
                        },
                    ],
                },
            ]
        },
        plugins: [
            new VueLoaderPlugin()
        ],
        resolve: {
            // 设置import或require时可以使用@作为路径, 如:
            alias: {
                '@': path.resolve('src')
            }
        }
    }
</code></pre>
<h2 id="vue3-webpack-electron"><a class="header" href="#vue3-webpack-electron">vue3 webpack electron</a></h2>
<p><a href="https://github.com/nofacer/vue3-electron">Vue3+Electron整合方式</a></p>
<pre><code>npm install -D electron

npm install -D electron-builder

指定 目标环境为: electron-renderer
配置 vue项目的打包输出 以及 electron 的打包输出
在 package.json 中指定electron启动的入口文件 electron 的打包输出的js文件
并添加:
    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;electron .&quot;,
        &quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;,
        &quot;dist&quot;: &quot;electron-builder&quot;
    },
    &quot;postinstall&quot;: &quot;electron-builder install-app-deps&quot;,
    &quot;build&quot;: {
        &quot;files&quot;: [
            &quot;./dist/**/*&quot;,
            &quot;./index.html&quot;
        ],
        &quot;directories&quot;: {
            &quot;output&quot;: &quot;package&quot;
        }
    },
&quot;build&quot; 用于 electron builder 需要打包哪些文件 以及 输出到哪里
</code></pre>
<p>webpack.config.js 配置:</p>
<pre><code class="language-javascript">const path = require('path')
const { VueLoaderPlugin } = require('vue-loader')

module.exports = {
    mode: 'development',
    target: &quot;electron-renderer&quot;,
    entry: {
        &quot;bundle&quot;: [&quot;./app.js&quot;],
        &quot;main&quot;: [&quot;./main.js&quot;]
    },
    output: {
        filename: '[name].js',
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.vue$/,
                loader: 'vue-loader'
            },
            // 普通的 `.scss` 文件和 `*.vue` 文件中的
            // `&lt;style lang=&quot;scss&quot;&gt;` 块都应用它
            {
                test: /\.scss$/,
                use: [
                    'style-loader',
                    'css-loader',
                    'sass-loader'
                ]
            },
            // 图片加载, base64数据, 如: &lt;img :src=&quot;require('@/img/vue_logo.png').default&quot;&gt;
            {
                test: /\.(png|jpg|gif)$/i,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 8192,
                        },
                    },
                ],
            },
        ]
    },
    plugins: [
        new VueLoaderPlugin()
    ],
    resolve: {
        // 设置import或require时可以使用@作为路径, 如:
        alias: {
            '@': path.resolve('src')
        }
    }
}
</code></pre>
<h2 id="vite-electron-创建-vite--electron-项目"><a class="header" href="#vite-electron-创建-vite--electron-项目">vite-electron 创建 vite + electron 项目</a></h2>
<pre><code>yarn create vite-electron electron-app
</code></pre>
<h2 id="使用-electron-vue-next-vite-vue3-electron"><a class="header" href="#使用-electron-vue-next-vite-vue3-electron">使用 electron-vue-next (vite vue3 electron)</a></h2>
<pre><code># 我使用默认配置
npm init electron-vue-next
</code></pre>
<h2 id="electron-默认不能在渲染进程中使用node环境"><a class="header" href="#electron-默认不能在渲染进程中使用node环境">electron 默认不能在渲染进程中使用node环境</a></h2>
<p><a href="https://www.electronjs.org/docs/tutorial/context-isolation">上下文隔离</a></p>
<h2 id="import-和-require-区别"><a class="header" href="#import-和-require-区别">import 和 require 区别</a></h2>
<p>在 typescript 使用 import<br />
在 js 中使用 require</p>
<h2 id="dplayer"><a class="header" href="#dplayer">dplayer</a></h2>
<p><a href="http://samples.mplayerhq.hu/">用于测试的视频</a></p>
<h2 id="ffmpeg-使用"><a class="header" href="#ffmpeg-使用">ffmpeg 使用</a></h2>
<pre><code># 生成 hls格式 视频
ffmpeg -i ./demo.mp4 -hls_time 10 -hls_list_size 0 -f hls test/demo.m3u8

~$ tree test/
test/
├── demo0.ts
├── demo1.ts
├── demo2.ts
├── demo3.ts
├── demo4.ts
├── demo5.ts
├── demo6.ts
└── demo.m3u8
</code></pre>
<h2 id="ffmpeg"><a class="header" href="#ffmpeg">ffmpeg</a></h2>
<pre><code># 安装 模拟的 video loop设备
https://github.com/umlaeute/v4l2loopback --&gt; make &amp;&amp; sudo make install-all, 加载ko并运行

# 强制 format ?
# v4l2loopback-ctl set-caps /dev/video0 &quot;UYVY:640x480&quot;

# 创建新loop设备
sudo v4l2loopback-ctl add -n &quot;loopy doopy&quot; /dev/video7

# 删除设备
sudo v4l2loopback-ctl delete /dev/video7

# 安装 v412-ctl 工具 (video4linux)
sudo apt install v4l-utils

# 当 设备 没有输入时 停留 3000ms 后, 输出 空帧 (但是继续输入, ffplay似乎不动了?)
v4l2-ctl -d /dev/video0 -c timeout=3000

# 超时图片, 取代空帧 ?
v4l2loopback-ctl set-timeout-image -t 3000 /dev/video0 service-unavailable.png

# 查看设备列表
v4l2-ctl --list-devices

# 查看当前摄像头支持的视频压缩格式
v4l2-ctl -d /dev/video0 --list-formats

# 改变分辨率, 同时, 会根据输出文件后缀改变 video format
ffmpeg -i demo.mp4 -vf scale=1280x720 output.mkv

# 输出视频数据到 /dev/video0 设备上
# read video in the real framerate
# input file
# webcams expect raw video
# the same format used by my real one
ffmpeg -re -i pickle-rick.mkv -vcodec rawvideo -pix_fmt yuv420p -framerate 25 -f v4l2 /dev/video0

# 播放 /dev/video0 上的视频数据 (没有声音)
ffplay /dev/video0

# 记录 /dev/video0 设备上的数据 10s, 输出到 output.mkv 文件
ffmpeg -f v4l2 -framerate 25 -video_size 640x480 -i /dev/video0 -t 00:00:10 output.mkv
</code></pre>
<h2 id="库"><a class="header" href="#库">库</a></h2>
<pre><code>pkg-config --cflags --libs gstreamer-1.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue-笔记"><a class="header" href="#vue-笔记">vue 笔记</a></h1>
<h2 id="使用vite工具"><a class="header" href="#使用vite工具">使用vite工具</a></h2>
<p><a href="https://cn.vitejs.dev/guide/">vite文档</a></p>
<h3 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h3>
<pre><code>yarn create @vitejs/app
</code></pre>
<h2 id="vuejs"><a class="header" href="#vuejs">vuejs</a></h2>
<p>1.如果一个数据依赖于其他数据，那么把这个数据设计为computed的<br />
2.如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git笔记"><a class="header" href="#git笔记">git笔记</a></h1>
<h2 id="第一次提交代码"><a class="header" href="#第一次提交代码">第一次提交代码</a></h2>
<pre><code>git init

git remote add origin git@gitee.com:imxood/stm32h750_rt_app.git
git pull origin master

git branch --set-upstream-to=origin/master

git add .
git commit -m &quot;.&quot;
git push
</code></pre>
<h2 id="远程url变更-更新本地-origin"><a class="header" href="#远程url变更-更新本地-origin">远程url变更, 更新本地 origin</a></h2>
<pre><code>git remote set-url origin  GIT_URL
</code></pre>
<h2 id="warning-crlf-will-be-replaced-by-lf"><a class="header" href="#warning-crlf-will-be-replaced-by-lf">warning: CRLF will be replaced by LF</a></h2>
<pre><code>git config --global core.autocrlf false
</code></pre>
<h2 id="执行-git-status-时-中文路径乱码解决"><a class="header" href="#执行-git-status-时-中文路径乱码解决">执行 git status 时 中文路径乱码解决:</a></h2>
<pre><code>git config --global core.quotepath false
</code></pre>
<h2 id="分支管理"><a class="header" href="#分支管理">分支管理</a></h2>
<h3 id="删除分支"><a class="header" href="#删除分支">删除分支</a></h3>
<pre><code># 删除本地分支
git branch -d localBranchName

# 删除远程分支
git push origin --delete remoteBranchName

# 删除后 同步分支
git fetch -p
</code></pre>
<h3 id="创建空的新分支"><a class="header" href="#创建空的新分支">创建空的新分支</a></h3>
<pre><code>git checkout --orphan main, 创建没有commits的孤儿分支
git add . &amp;&amp; git commit -m &quot;.&quot;
git push --set-upstream origin main
</code></pre>
<h2 id="git-remote"><a class="header" href="#git-remote">git remote</a></h2>
<pre><code>git remote -v, 显示当前远程仓库信息
git remote set-url origin https://github.com/imxood/mdbook-katex.git, 设置远程仓库
</code></pre>
<h2 id="workflow"><a class="header" href="#workflow">workflow</a></h2>
<p>参考: <a href="https://docs.github.com/cn/actions/creating-actions/metadata-syntax-for-github-actions">GitHub Actions 的元数据语法</a></p>
<p>参考: <a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions">GitHub Actions 的工作流程语法</a></p>
<h2 id="github-reset-api"><a class="header" href="#github-reset-api">github reset api</a></h2>
<p>参考: <a href="https://docs.github.com/cn/rest/guides/getting-started-with-the-rest-api">getting-started-with-the-rest-api</a></p>
<p>参考: <a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api">Resources in the REST API</a></p>
<pre><code>不使用认证将只有每小时60次请求的限制
    curl -i https://api.github.com/users/imxood

使用认证将有每小时5000次请求
    curl -i -u username:$token https://api.github.com/users/octocat

Shell - Get latest release from GitHub
    curl --silent &quot;https://api.github.com/repos/$1/releases/latest&quot; | grep -Po '&quot;tag_name&quot;: &quot;\K.*?(?=&quot;)'
</code></pre>
<h2 id="github-actions"><a class="header" href="#github-actions">github actions</a></h2>
<h3 id="环境文件"><a class="header" href="#环境文件">环境文件</a></h3>
<pre><code>\$GITHUB_PATH, 用于添加系统路径

    GITHUB_PATH 这个环境变量表示一个环境变量文件, 所有后续操作将会将这个文件中的值添加到系统Path中.

    echo &quot;{path}&quot; &gt;&gt; \$GITHUB_PATH
    或者是 打开 \$GITHUB_PATH 文件, 写路径

\$GITHUB_ENV, 用于设置环境变量

    跟上面是类似的.
    echo &quot;{name}={value}&quot; &gt;&gt; \$GITHUB_ENV
</code></pre>
<h2 id="同步fork上游的代码"><a class="header" href="#同步fork上游的代码">同步fork上游的代码</a></h2>
<p>查看远程状态</p>
<pre><code>git remote -v
</code></pre>
<p>添加 fork的上游仓库</p>
<pre><code>git remote add upstream https://github.com/larksuite/rsmpeg.git
</code></pre>
<p>再次 查看状态是否被添加</p>
<pre><code>git remote -v
</code></pre>
<p>获取上游的更新, 会被存储到本地分支 upstream/master</p>
<pre><code>git fetch upstream
</code></pre>
<p>切换到本地要merge的分支 master</p>
<pre><code>git checkout master
</code></pre>
<p>把 upstream/master 分支 merge 到本地 master</p>
<pre><code>git merge upstream/master
</code></pre>
<p>提交</p>
<pre><code>git push origin master</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown-常用语法"><a class="header" href="#markdown-常用语法">markdown 常用语法</a></h1>
<h2 id="数学公式"><a class="header" href="#数学公式">数学公式</a></h2>
<p>参考: <a href="https://www.jianshu.com/p/e74eb43960a1">DanielGavin - Markdown数学公式语法</a></p>
<p>参考: <a href="https://katex.org/docs/supported.html">katex Supported Functions</a></p>
<h3 id="行内与独行"><a class="header" href="#行内与独行">行内与独行</a></h3>
<ol>
<li>行内公式: 将公式插入到本行内, 符号: $公式内容$, 如:  $xyz$, $xyz$</li>
<li>独行公式: 将公式插入到新的一行内, 并且居中, 符号: $$公式内容$$, 如: $$xyz$$, $$xyz$$</li>
</ol>
<h3 id="上标下标与组合"><a class="header" href="#上标下标与组合">上标、下标与组合</a></h3>
<ol>
<li>上标符号, 符号: ^, 如: $x^4$, $x^4$</li>
<li>下标符号, 符号: _, 如: $x_1$, $x_1$</li>
<li>组合符号, 符号: {}, 如: ${16}<em>{8}O{2+}</em>{2}$, ${16}<em>{8}O{2+}</em>{2}$</li>
</ol>
<h3 id="汉字字体与格式"><a class="header" href="#汉字字体与格式">汉字、字体与格式</a></h3>
<ol>
<li>
<p>汉字形式, 符号: \mbox{}, 如: $V_{\mbox{初始}}$
$$V_{\mbox{初始}}$$</p>
</li>
<li>
<p>字体控制, 符号: \displaystyle, 如: $\displaystyle \frac{x+y}{y+z}$
$$\displaystyle \frac{x+y}{y+z}$$</p>
</li>
<li>
<p>下划线符号, 符号: \underline, 如: $\underline{x+y}$
$$\underline{x+y}$$</p>
</li>
<li>
<p>标签, 符号\tag{数字}, 似乎只能用独行形式, 如: $$\tag*{hi} x+y^{2x}$$, $$\tag{hi} x+y^{2x}$$
$$\tag*{hi} x+y^{2x}$$ $$\tag{hi} x+y^{2x}$$</p>
</li>
<li>
<p>上大括号, 符号: \overbrace{算式}, 如: $\overbrace{a+b+c+d}^{2.0}$
$$\overbrace{a+b+c+d}^{2.0}$$</p>
</li>
<li>
<p>下大括号, 符号: \underbrace{算式}, 如: $a+\underbrace{b+c}<em>{1.0}+d$
$$a+\underbrace{b+c}</em>{1.0}+d$$</p>
</li>
<li>
<p>上位符号, 符号: \stacrel{上位符号}{基位符号}, 如: $\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$
$$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$$</p>
</li>
</ol>
<h3 id="占位符"><a class="header" href="#占位符">占位符</a></h3>
<ol>
<li>两个quad空格, 符号: \qquad, 如: $x \qquad y$, $x \qquad y$</li>
<li>quad空格, 符号: \quad, 如: $x \quad y$, $x \quad y$</li>
<li>大空格, 符号: , 如: $x \ y$, $x \ y$</li>
<li>中空格, 符号: , 如: $x : y$, $x : y$</li>
<li>小空格, 符号: ,, 如: $x , y$, $x , y$</li>
<li>没有空格, 如: $xy$, $xy$</li>
<li>紧贴, 符号: \!, 如: $x \! y$, $x ! y$</li>
</ol>
<h3 id="定界符与组合"><a class="header" href="#定界符与组合">定界符与组合</a></h3>
<ol>
<li>
<p>括号, 符号: ()\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</p>
<p>如: $()\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$
$$()\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$$</p>
</li>
<li>
<p>中括号, 符号: [], 如: $[x+y]$, $[x+y]$</p>
</li>
<li>
<p>大括号, 符号: { }, 如: ${x+y}$, ${x+y}$</p>
</li>
<li>
<p>自适应括号, 符号: \left \right, 如: $\left(x\right)$, $\left(x{yz}\right)$</p>
<p>$\left(x\right)$, $\left(x{yz}\right)$</p>
</li>
<li>
<p>组合公式, 符号: {上位公式 \choose 下位公式}</p>
<p>如: ${n+1 \choose k}={n \choose k}+{n \choose k-1}$
$${n+1 \choose k}={n \choose k}+{n \choose k-1}$$</p>
</li>
<li>
<p>组合公式, 符号: {上位公式 \atop 下位公式}</p>
<p>如: $\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$
$$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$$</p>
</li>
</ol>
<h3 id="四则运算"><a class="header" href="#四则运算">四则运算</a></h3>
<ol>
<li>
<p>加法运算, 符号: +, 如: $x+y=z$ $$x+y=z$$</p>
</li>
<li>
<p>减法运算, 符号: -, 如: $x-y=z$ $$x-y=z$$</p>
</li>
<li>
<p>加减运算, 符号: \pm, 如: $x \pm y=z$ $$x \pm y=z$$</p>
</li>
<li>
<p>减甲运算, 符号: \mp, 如: $x \mp y=z$ $$x \mp y=z$$</p>
</li>
<li>
<p>乘法运算, 符号: \times, 如: $x \times y=z$ $$x \times y=z$$</p>
</li>
<li>
<p>点乘运算, 符号: \cdot, 如: $x \cdot y=z$ $$x \cdot y=z$$</p>
</li>
<li>
<p>星乘运算, 符号: \ast, 如: $x \ast y=z$ $$x \ast y=z$$</p>
</li>
<li>
<p>除法运算, 符号: \div, 如: $x \div y=z$ $$x \div y=z$$</p>
</li>
<li>
<p>斜法运算, 符号: /, 如: $x/y=z$ $$x/y=z$$</p>
</li>
<li>
<p>分式表示, 符号: \frac{分子}{分母}, 如: $\frac{x+y}{y+z}$
$$\frac{x+y}{y+z}$$</p>
</li>
<li>
<p>分式表示, 符号: {分子} \voer {分母}, 如: ${x+y} \over {y+z}$ $${x+y} \over {y+z}$$</p>
</li>
<li>
<p>绝对值表示, 符号: ||, 如: $|x+y|$ $$|x+y|$$</p>
</li>
</ol>
<h3 id="高级运算"><a class="header" href="#高级运算">高级运算</a></h3>
<ol>
<li>
<p>平均数运算, 符号: \overline{算式}, 如: $\overline{xyz}$
$$\overline{xyz}$$</p>
</li>
<li>
<p>开二次方运算, 符号: \sqrt, 如: $\sqrt x$
$$\sqrt x$$</p>
</li>
<li>
<p>开方运算, 符号: \sqrt[开方数]{被开方数}, 如: $\sqrt[3]{x+y}$
$$\sqrt[3]{x+y}$$</p>
</li>
<li>
<p>对数运算, 符号: \log, 如: $\log(x)$
$$\log(x)$$</p>
</li>
<li>
<p>极限运算, 符号: \lim, 如: $\lim^{x \to \infty}<em>{y \to 0}{\frac{x}{y}}$
$$\lim^{x \to \infty}</em>{y \to 0}{\frac{x}{y}}$$</p>
</li>
<li>
<p>极限运算, 符号: \displaystyle \lim, 如: $\displaystyle \lim^{x \to \infty}<em>{y \to 0}{\frac{x}{y}}$
$$\displaystyle \lim^{x \to \infty}</em>{y \to 0}{\frac{x}{y}}$$</p>
</li>
<li>
<p>求和运算, 符号: \sum, 如: $\sum^{x \to \infty}<em>{y \to 0}{\frac{x}{y}}$
$$\sum^{x \to \infty}</em>{y \to 0}{\frac{x}{y}}$$</p>
</li>
<li>
<p>求和运算, 符号: \displaystyle \sum, 如: $\displaystyle \sum^{x \to \infty}<em>{y \to 0}{\frac{x}{y}}$
$$\displaystyle \sum^{x \to \infty}</em>{y \to 0}{\frac{x}{y}}$$</p>
</li>
<li>
<p>积分运算, 符号: \int, 如: $\int^{\infty}<em>{0}{xdx}$
$$\int^{\infty}</em>{0}{xdx}$$</p>
</li>
<li>
<p>积分运算, 符号: \displaystyle \int, 如: $\displaystyle \int^{\infty}<em>{0}{xdx}$
$$\displaystyle \int^{\infty}</em>{0}{xdx}$$</p>
</li>
<li>
<p>微分运算, 符号: \partial, 如: $\frac{\partial x}{\partial y}$
$$\frac{\partial x}{\partial y}$$</p>
</li>
<li>
<p>矩阵表示, 符号: \begin{matrix} \end{matrix}, 如: $\begin{matrix} a &amp; b \ c &amp; d \end{matrix}$
$$\begin{matrix} a &amp; b \ c &amp; d \end{matrix}$$</p>
</li>
</ol>
<h3 id="逻辑运算"><a class="header" href="#逻辑运算">逻辑运算</a></h3>
<ol>
<li>
<p>等于运算, 符号: =, 如: $x+y=z$
$$x+y=z$$</p>
</li>
<li>
<p>大于运算, 符号: &gt;, 如: $x+y&gt;z$
$$x+y&gt;z$$</p>
</li>
<li>
<p>小于运算, 符号: &lt;, 如: $x+y&lt;z$
$$x+y&lt;z$$</p>
</li>
<li>
<p>大于等于运算, 符号: \geq, 如: $x+y \geq z$
$$x+y \geq z$$</p>
</li>
<li>
<p>小于等于运算, 符号: \leq, 如: $x+y \leq z$
$$x+y \leq z$$</p>
</li>
<li>
<p>不等于运算, 符号: \neq, 如: $x+y \neq z$
$$x+y \neq z$$</p>
</li>
<li>
<p>不大于等于运算, 符号: \ngeq, 如: $x+y \ngeq z$
$$x+y \ngeq z$$</p>
</li>
<li>
<p>不大于等于运算, 符号: \not\geq, 如: $x+y \not\geq z$
$$x+y \not\geq z$$</p>
</li>
<li>
<p>不小于等于运算, 符号: \nleq, 如: $x+y \nleq z$
$$x+y \nleq z$$</p>
</li>
<li>
<p>不小于等于运算, 符号: \not\leq, 如: $x+y \not\leq z$
$$x+y \not\leq z$$</p>
</li>
<li>
<p>约等于运算, 符号: \approx, 如: $x+y \approx z$
$$x+y \approx z$$</p>
</li>
<li>
<p>恒定等于运算, 符号: \equiv, 如: $x+y \equiv z$
$$x+y \equiv z$$</p>
</li>
</ol>
<h3 id="集合运算"><a class="header" href="#集合运算">集合运算</a></h3>
<ol>
<li>属于运算, 符号: \in, 如: $x \in y$, $x \in y$</li>
<li>不属于运算, 符号: \notin, 如: $x \notin y$, $x \notin y$</li>
<li>不属于运算, 符号: \not\in, 如: $x \not\in y$, $x \not\in y$</li>
<li>子集运算, 符号: \subset, 如: $x \subset y$, $x \subset y$</li>
<li>子集运算, 符号: \supset, 如: $x \supset y$, $x \supset y$</li>
<li>真子集运算, 符号: \subseteq, 如: $x \subseteq y$, $x \subseteq y$</li>
<li>非真子集运算, 符号: \subsetneq, 如: $x \subsetneq y$, $x \subsetneq y$</li>
<li>真子集运算, 符号: \supseteq, 如: $x \supseteq y$, $x \supseteq y$</li>
<li>非真子集运算, 符号: \supsetneq, 如: $x \supsetneq y$, $x \supsetneq y$</li>
<li>非子集运算, 符号: \not\subset, 如: $x \not\subset y$, $x \not\subset y$</li>
<li>非子集运算, 符号: \not\supset, 如: $x \not\supset y$, $x \not\supset y$</li>
<li>并集运算, 符号: \cup, 如: $x \cup y$, $x \cup y$</li>
<li>交集运算, 符号: \cap, 如: $x \cap y$, $x \cap y$</li>
<li>差集运算, 符号: \setminus, 如: $x \setminus y$, $x \setminus y$</li>
<li>同或运算, 符号: \bigodot, 如: $x \bigodot y$, $x \bigodot y$</li>
<li>同与运算, 符号: \bigotimes, 如: $x \bigotimes y$, $x \bigotimes y$</li>
<li>实数集合, 符号: \mathbb{R}, 如: $\mathbb{R}$, $\mathbb{R}$</li>
<li>自然数集合, 符号: \mathbb{Z}, 如: $\mathbb{Z}$, $\mathbb{Z}$</li>
<li>空集, 符号: \emptyset, 如: $\emptyset$, $\emptyset$</li>
</ol>
<h3 id="数学符号"><a class="header" href="#数学符号">数学符号</a></h3>
<ol>
<li>无穷, 符号: \infty, 如: $\infty$, $\infty$</li>
<li>虚数, 符号: \imath, 如: $\imath$, $\imath$</li>
<li>虚数, 符号: \jmath, 如: $\jmath$, $\jmath$</li>
<li>数学符号, 符号\hat{a}, 如: $\hat{a}$, $\hat{a}$</li>
<li>数学符号, 符号\check{a}, 如: $\check{a}$, $\check{a}$</li>
<li>数学符号, 符号\breve{a}, 如: $\breve{a}$, $\breve{a}$</li>
<li>数学符号, 符号\tilde{a}, 如: $\tilde{a}$, $\tilde{a}$</li>
<li>数学符号, 符号\bar{a}, 如: $\bar{a}$, $\bar{a}$</li>
<li>矢量符号, 符号\vec{a}, 如: $\vec{a}$, $\vec{a}$</li>
<li>数学符号, 符号\acute{a}, 如: $\acute{a}$, $\acute{a}$</li>
<li>数学符号, 符号\grave{a}, 如: $\grave{a}$, $\grave{a}$</li>
<li>数学符号, 符号\mathring{a}, 如: $\mathring{a}$, $\mathring{a}$</li>
<li>一阶导数符号, 符号\dot{a}, 如: $\dot{a}$, $\dot{a}$</li>
<li>二阶导数符号, 符号\ddot{a}, 如: $\ddot{a}$, $\ddot{a}$</li>
<li>上箭头, 符号: \uparrow, 如: $\uparrow$, $\uparrow$</li>
<li>上箭头, 符号: \Uparrow, 如: $\Uparrow$, $\Uparrow$</li>
<li>下箭头, 符号: \downarrow, 如: $\downarrow$, $\downarrow$</li>
<li>下箭头, 符号: \Downarrow, 如: $\Downarrow$, $\Downarrow$</li>
<li>左箭头, 符号: \leftarrow, 如: $\leftarrow$, $\leftarrow$</li>
<li>左箭头, 符号: \Leftarrow, 如: $\Leftarrow$, $\Leftarrow$</li>
<li>右箭头, 符号: \rightarrow, 如: $\rightarrow$, $\rightarrow$</li>
<li>右箭头, 符号: \Rightarrow, 如: $\Rightarrow$, $\Rightarrow$</li>
<li>底端对齐的省略号, 符号: \ldots, 如: $1,2,\ldots,n$, $1,2,\ldots,n$</li>
<li>中线对齐的省略号, 符号: \cdots, 如: $x_1^2 + x_2^2 + \cdots + x_n^2$, $x_1^2 + x_2^2 + \cdots + x_n^2$</li>
<li>竖直对齐的省略号, 符号: \vdots, 如: $\vdots$, $\vdots$</li>
<li>斜对齐的省略号, 符号: \ddots, 如: $\ddots$, $\ddots$</li>
</ol>
<h3 id="希腊字母"><a class="header" href="#希腊字母">希腊字母</a></h3>
<table><thead><tr><th style="text-align: center">No.</th><th style="text-align: center">Lowercase</th><th style="text-align: center">Uppercase</th><th style="text-align: center">English</th><th style="text-align: center">IPA</th></tr></thead><tbody>
<tr><td style="text-align: center">$1$</td><td style="text-align: center">$\alpha$</td><td style="text-align: center">$A$</td><td style="text-align: center">$alpha$</td><td style="text-align: center"><strong>/'ælfə/</strong></td></tr>
<tr><td style="text-align: center">$2$</td><td style="text-align: center">$\beta$</td><td style="text-align: center">$B$</td><td style="text-align: center">$beta$</td><td style="text-align: center"><strong>/'bi:tə/or/'beɪtə/</strong></td></tr>
<tr><td style="text-align: center">$3$</td><td style="text-align: center">$\gamma$</td><td style="text-align: center">$\Gamma$</td><td style="text-align: center">$gamma$</td><td style="text-align: center"><strong>/'gæmə/</strong></td></tr>
<tr><td style="text-align: center">$4$</td><td style="text-align: center">$\delta$</td><td style="text-align: center">$\Delta$</td><td style="text-align: center">$delta$</td><td style="text-align: center"><strong>/'deltə/</strong></td></tr>
<tr><td style="text-align: center">$5$</td><td style="text-align: center">$\epsilon$</td><td style="text-align: center">$E$</td><td style="text-align: center">$epsilon$</td><td style="text-align: center"><strong>/'epsɪlɒn/</strong></td></tr>
<tr><td style="text-align: center">$6$</td><td style="text-align: center">$\zeta$</td><td style="text-align: center">$Z$</td><td style="text-align: center">$zeta$</td><td style="text-align: center"><strong>/'zi:tə/</strong></td></tr>
<tr><td style="text-align: center">$7$</td><td style="text-align: center">$\eta$</td><td style="text-align: center">$H$</td><td style="text-align: center">$eta$</td><td style="text-align: center"><strong>/'i:tə/</strong></td></tr>
<tr><td style="text-align: center">$8$</td><td style="text-align: center">$\theta$</td><td style="text-align: center">$\Theta$</td><td style="text-align: center">$theta$</td><td style="text-align: center"><strong>/'θi:tə/</strong></td></tr>
<tr><td style="text-align: center">$9$</td><td style="text-align: center">$\iota$</td><td style="text-align: center">$I$</td><td style="text-align: center">$iota$</td><td style="text-align: center"><strong>/aɪ'əʊtə/</strong></td></tr>
<tr><td style="text-align: center">$10$</td><td style="text-align: center">$\kappa$</td><td style="text-align: center">$K$</td><td style="text-align: center">$kappa$</td><td style="text-align: center"><strong>/'kæpə/</strong></td></tr>
<tr><td style="text-align: center">$11$</td><td style="text-align: center">$\lambda$</td><td style="text-align: center">$\lambda$</td><td style="text-align: center">$lambda$</td><td style="text-align: center"><strong>/'læmdə/</strong></td></tr>
<tr><td style="text-align: center">$12$</td><td style="text-align: center">$\mu$</td><td style="text-align: center">$M$</td><td style="text-align: center">$mu$</td><td style="text-align: center"><strong>/mju:/</strong></td></tr>
<tr><td style="text-align: center">$13$</td><td style="text-align: center">$\nu$</td><td style="text-align: center">$N$</td><td style="text-align: center">$nu$</td><td style="text-align: center"><strong>/nju:/</strong></td></tr>
<tr><td style="text-align: center">$14$</td><td style="text-align: center">$\xi$</td><td style="text-align: center">$\Xi$</td><td style="text-align: center">$xi$</td><td style="text-align: center"><strong>/ksi/or/'zaɪ/or/'ksaɪ/</strong></td></tr>
<tr><td style="text-align: center">$15$</td><td style="text-align: center">$\omicron$</td><td style="text-align: center">$O$</td><td style="text-align: center">$omicron$</td><td style="text-align: center"><strong>/əu'maikrən/or/'ɑmɪ,krɑn/</strong></td></tr>
<tr><td style="text-align: center">$16$</td><td style="text-align: center">$\pi$</td><td style="text-align: center">$\Pi$</td><td style="text-align: center">$pi$</td><td style="text-align: center"><strong>/paɪ/</strong></td></tr>
<tr><td style="text-align: center">$17$</td><td style="text-align: center">$\rho$</td><td style="text-align: center">$P$</td><td style="text-align: center">$rho$</td><td style="text-align: center"><strong>/rəʊ/</strong></td></tr>
<tr><td style="text-align: center">$18$</td><td style="text-align: center">$\sigma$</td><td style="text-align: center">$\Sigma$</td><td style="text-align: center">$sigma$</td><td style="text-align: center"><strong>/'sɪɡmə/</strong></td></tr>
<tr><td style="text-align: center">$19$</td><td style="text-align: center">$\tau$</td><td style="text-align: center">$T$</td><td style="text-align: center">$tau$</td><td style="text-align: center"><strong>/tɔ:/or/taʊ/</strong></td></tr>
<tr><td style="text-align: center">$20$</td><td style="text-align: center">$\upsilon$</td><td style="text-align: center">$\Upsilon$</td><td style="text-align: center">$upsilon$</td><td style="text-align: center"><strong>/'ipsilon/or/'ʌpsilɒn/</strong></td></tr>
<tr><td style="text-align: center">$21$</td><td style="text-align: center">$\phi$</td><td style="text-align: center">$\Phi$</td><td style="text-align: center">$phi$</td><td style="text-align: center"><strong>/faɪ/</strong></td></tr>
<tr><td style="text-align: center">$22$</td><td style="text-align: center">$\chi$</td><td style="text-align: center">$X$</td><td style="text-align: center">$chi$</td><td style="text-align: center"><strong>/kaɪ/</strong></td></tr>
<tr><td style="text-align: center">$23$</td><td style="text-align: center">$\psi$</td><td style="text-align: center">$\Psi$</td><td style="text-align: center">$psi$</td><td style="text-align: center"><strong>/psaɪ/</strong></td></tr>
<tr><td style="text-align: center">$24$</td><td style="text-align: center">$\omega$</td><td style="text-align: center">$\Omega$</td><td style="text-align: center">$omega$</td><td style="text-align: center"><strong>/'əʊmɪɡə/or/oʊ'meɡə/</strong></td></tr>
</tbody></table>
<h2 id="test"><a class="header" href="#test">test</a></h2>
<table><thead><tr><th>header1</th><th>header2</th></tr></thead><tbody>
<tr><td>$\omega$</td><td>$\omega$</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-构建工具"><a class="header" href="#mdbook-构建工具">mdbook 构建工具</a></h1>
<p><a href="https://rust-lang.github.io/mdBook/index.html">官方文档</a></p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<ul>
<li>
<p>方法1. <a href="https://github.com/rust-lang/mdBook/releases">预编译文件</a></p>
</li>
<li>
<p>方法2. 编译:</p>
<p><code>cargo install mdbook</code></p>
</li>
</ul>
<h2 id="mdbook-用法"><a class="header" href="#mdbook-用法">mdbook 用法</a></h2>
<pre><code>mdbook --help
mdbook &lt;SUBCOMMAND&gt; --help

mdbook init 初始化项目
mdbook init --theme, 初始化项目, 并复制默认的theme到你的项目目录
mdbook build, 编译生成静态文件
mdbook watch --open, 编译成静态文件并打开浏览器, 如果文件改变就重新build
mdbook serve --open, 编译成静态文件并创建server, 打开浏览器, 如果文件改变就重新build
</code></pre>
<h2 id="booktoml-配置"><a class="header" href="#booktoml-配置">book.toml 配置</a></h2>
<p>output.html.print 是否开起打印功能, 打印功能是 它打开生成的一个包含所有内容的print.html页面, 然后打印这个文件...如果保存为pdf的话没有目录</p>
<p>no-section-label 这个可以去掉侧边栏的数字前缀</p>
<p>output.html.fold 可以控制sidebar是否可以折叠及默认行为</p>
<h2 id="preprocessor"><a class="header" href="#preprocessor">preprocessor</a></h2>
<p><a href="https://github.com/lzanini/mdbook-katex">数学公式 mdbook-katex</a></p>
<p><a href="https://github.com/badboy/mdbook-mermaid">流程图 mdbook-mermaid</a></p>
<p>cargo install mdbook-katex</p>
<p>cargo install mdbook-mermaid
mdbook-mermaid install path/to/your/book</p>
<h2 id="源码分析"><a class="header" href="#源码分析">源码分析</a></h2>
<ol>
<li>
<p>使用 <code>env_logger</code> 输出log, 通过 RUST_LOG 环境变量 控制 log 的输出, 如: <code>export RUST_LOG=mdbook</code>, 启用可执行程序 mdbook 的 all logging</p>
</li>
<li>
<p>使用 <code>clap</code> 解析命令行参数</p>
</li>
<li>
<p>加载配置</p>
<p>使用 <code>toml</code> 加载 book.toml文件, 并序列化成 BookConfig对象. BookConfig对象需要实现 serde 的 Deserialize</p>
<p>使用 <code>std::env</code> 读取环境变量, 根据环境变量中 &quot;MDBOOK_&quot; 前缀的变量更新配置</p>
<p>如: MDBOOK_BOOK__TITLE=&quot;Hello&quot; 即设置 book.title 的值为&quot;Hello&quot;</p>
</li>
<li>
<p>解析 SUMMARY.md 文件, 得到 book 对象, 包含了每一个章节的content.</p>
<p>使用 <code>pulldown-cmark</code> 解析 markdown文件</p>
<p>核心思想: pull parser, 像游标一样移动, 提供 <code>self.stream.next()</code> 这样的方法向前移动游标, 返回值为解析到的事件, 对特定事件处理并loop.</p>
<p>比如: <code>Event::Start(Tag::Heading(1))</code>, 如果检查到这个事件就执行:</p>
<pre><code>    let tags = collect_events!(self.stream, end Tag::Heading(1));
</code></pre>
<p>这样就能拿到解析到的数据. 通过对不同的事件处理 并 loop, 完成解析工作.</p>
<p><code>parse_numbered</code>, 解析中间部分的列表. 即: Numbered Chapter</p>
<p><code>parse_nested_numbered</code>, 用于解析一个子列表</p>
<p><code>parse_nested_item</code>, 用于解析子列表中的某一项</p>
<p><code>next_event()</code> 中, 通过 <code>parser.back.take()</code> 若为None则向前移动游标, 否则就返回 <code>back.take()</code>的结果.</p>
<pre><code> 例子1:

- [首页](./README.md)

具体的event过程:
   Parsing prefix items
   Next event: Some(Start(List(None)))
   Next event: Some(Start(Item))
   Next event: Some(Start(Link(Inline, Borrowed(&quot;./README.md&quot;), Borrowed(&quot;&quot;))))
   Next event: Some(Text(Borrowed(&quot;首页&quot;)))
   Next event: Some(End(Link(Inline, Borrowed(&quot;./README.md&quot;), Borrowed(&quot;&quot;))))
   Next event: Some(End(Item))
   Next event: Some(End(List(None)))
   Next event: Some(Start(Heading(1)))
   Back: Start(Heading(1))

例子2:

- [硬件]()
   - [晶体管](./hardware/晶体管.md)
   - [MOS管](./hardware/MOS管.md)

具体的event过程:
   Parsing numbered chapters at level 0
   Next event: Some(Start(List(None)))
   Next event: Some(Start(Item))
   Next event: Some(Start(Paragraph))
   Next event: Some(Start(Link(Inline, Borrowed(&quot;&quot;), Borrowed(&quot;&quot;))))
   Next event: Some(Text(Borrowed(&quot;硬件&quot;)))
   Next event: Some(End(Link(Inline, Borrowed(&quot;&quot;), Borrowed(&quot;&quot;))))
   Found chapter: 1. 硬件 ([draft])
   Next event: Some(End(Paragraph))
   Next event: Some(Start(List(None)))
   Parsing numbered chapters at level 1.
   Next event: Some(Start(Item))
   Next event: Some(Start(Link(Inline, Borrowed(&quot;./hardware/晶体管.md&quot;), Borrowed(&quot;&quot;))))
   Next event: Some(Text(Borrowed(&quot;晶体管&quot;)))
   Next event: Some(End(Link(Inline, Borrowed(&quot;./hardware/晶体管.md&quot;), Borrowed(&quot;&quot;))))
   Found chapter: 1.1. 晶体管 (./hardware/晶体管.md)
   Next event: Some(End(Item))
   Next event: Some(Start(Item))
   Next event: Some(Start(Link(Inline, Borrowed(&quot;./hardware/MOS管.md&quot;), Borrowed(&quot;&quot;))))
   Next event: Some(Text(Borrowed(&quot;MOS管&quot;)))
   Next event: Some(End(Link(Inline, Borrowed(&quot;./hardware/MOS管.md&quot;), Borrowed(&quot;&quot;))))
   Found chapter: 1.2. MOS管 (./hardware/MOS管.md)
   Next event: Some(End(Item))
   Next event: Some(End(List(None)))
</code></pre>
</li>
<li>
<p>preprocessor</p>
<p>preprocessor 以子进程的方式被 mdbook主程序 调用, mdbook主程序 把 book 对象 以stdio 的方式传递给 preprocessor进程, preprocessor进程对每一个章节的内容进行预处理</p>
</li>
<li>
<p>renderer工作过程</p>
<p>默认使用的是 &quot;html&quot;渲染器, 用于把 preprocessor 的结果解析成html页面.</p>
</li>
<li>
<p>使用 <code>notify</code> 捕获特定路径下文件的changed事件</p>
</li>
<li>
<p>使用 <code>warp</code> 用于创建http server 和 websocket server, 提供 web服务, 并支持 reload</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-工具"><a class="header" href="#linux-工具">linux 工具</a></h1>
<h2 id="flameshot-截图工具"><a class="header" href="#flameshot-截图工具">flameshot 截图工具</a></h2>
<p>命令: flameshot gui, 进入截图</p>
<h2 id="dsview-逻辑分析器"><a class="header" href="#dsview-逻辑分析器">DSView 逻辑分析器</a></h2>
<h3 id="编译"><a class="header" href="#编译">编译</a></h3>
<pre><code>git clone https://github.com/DreamSourceLab/DSView.git

sudo apt-get install git-core build-essential cmake autoconf automake libtool pkg-config \
libglib2.0-dev libzip-dev libudev-dev libusb-1.0-0-dev \
python3-dev qt5-default libboost-dev libboost-test-dev libboost-thread-dev libboost-system-dev libboost-filesystem-dev check libfftw3-dev

cd libsigrok4DSL
./autogen.sh
./configure
make -j
sudo make install
cd ..

cd libsigrokdecode4DSL
./autogen.sh
./configure
make -j
sudo make install
cd ..

cd DSView
mkdir build -p &amp;&amp; cd build &amp;&amp; cmake ..
make -j
sudo make install
</code></pre>
<h2 id="wps-中文字体部分无显示"><a class="header" href="#wps-中文字体部分无显示">wps 中文字体部分无显示</a></h2>
<p><a href="https://mxy493.xyz/2019040840601/">添加字体， 更新字体缓存</a> 需要重启生效(或登出?)</p>
<h2 id="samba-共享"><a class="header" href="#samba-共享">Samba 共享</a></h2>
<p>安装</p>
<pre><code>sudo apt-get install samba
</code></pre>
<p>修改 /etc/samba/smb.cof</p>
<pre><code>[profiles]
comment = Share Folder
path = /develop/share
guest ok = yes
browseable = yes
public = yes
writable = yes
force users = nobody
force group = nogroup
force create mode = 0775
force directory mode = 0775
</code></pre>
<p><a href="https://segmentfault.com/a/1190000039363538">linux访问windows的共享</a></p>
<h2 id="bt-下载工具----tixati"><a class="header" href="#bt-下载工具----tixati">BT 下载工具 -- Tixati</a></h2>
<p>使用Tixati, 在界面上, 点击Transfers, 点击 &quot;Add&quot;, 打开URL, 输入 BT链接, 就会搜索资源, 点击 Start 开始下载</p>
<h2 id="python-版本管理工具----pyenv"><a class="header" href="#python-版本管理工具----pyenv">python 版本管理工具 -- pyenv</a></h2>
<pre><code>https://github.com/pyenv/pyenv

安装：

    git clone https://github.com/pyenv/pyenv.git ~/.pyenv

    cd ~/.pyenv &amp;&amp; src/configure &amp;&amp; make -C src

    echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bash_profile
    echo 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile
    eval &quot;$(pyenv init -)&quot;

用法：

    pyenv install -l

    pyenv install 3.9.6

    pyenv global 3.9.6
    pyenv local 3.9.6

    查看当前版本：
        pyenv version

    查看当前所有的版本：
        pyenv versions
    
    python --version
    pip --version

    pyenv local 3.9.6 当前目录下自动创建环境
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阿里云-oss-bucket"><a class="header" href="#阿里云-oss-bucket">阿里云 OSS Bucket</a></h1>
<p><a href="https://help.aliyun.com/document_detail/31947.html?spm=a2c4g.11186623.6.1603.47db55acvmevIS">OSS简介</a></p>
<p><a href="https://help.aliyun.com/document_detail/31948.html?spm=a2c4g.11186623.2.3.2e0a2635L6PAR0">API参考</a></p>

                        <script src="https://utteranc.es/client.js"
                            repo="imxood/imxood.github.io"
                            issue-term="pathname"
                            theme="boxy-light"
                            crossorigin="anonymous"
                            async>
                        </script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom/mermaid.min.js"></script>
        <script type="text/javascript" src="theme/custom/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
