# C语言笔记

## 大小端: 小端低低

    小端, 低位在低地址:
        uint8_t data[] = {0x01, 0x02};
        uint32_t d = *((uint32 *)data);

        d ==> 0x0201

## 结构体

    !!! 这三条直接影响结构体对齐:
        <1> __attribute__((aligned(ALIGNED_SIZE))), 结构体的对齐字节是ALIGNED_SIZE, 2的次方
        <2> #pragma pack(ALIGNED_SIZE), 结构体的对齐字节是ALIGNED_SIZE, 2的次方
        <3> 使用__attribute__ ((__packed__))修饰时, 结构体不要对齐

### 内存对齐

    目的:
        1. 平台移植
        2. 更好性能, 访问未对齐的内存, 处理器需要两次访问内存, 而对齐的只需要访问一次


    三条规则:
        1. 首元素偏移量是0
        2. 成员对齐, 每个成员的偏移量是当前成员大小的整数倍
        3. 结构体对齐, 其对齐字节数是结构体最大成员字节数, 结构体的总大小是对齐字节数的整数倍

### 位域

    信息在存储时, 并不需要完整的字节, 可能需要操作某些位, 这时就该使用位域了

    位段成员必须声明为 (unsigned) int8_t, int16_t 或 int32_t 类型

    规则:

        1) 如果后面的位域字段与前一个位域字段之和小于前一个位域字段类型的位宽, 则后面一个紧邻前一个存储, 直到不能存储
        2) 如果后面的位域字段与前一个位域字段之和大于前一个位域字段类型的位宽, 则后面一个将从新的存储单元开始
        3) 结构体对齐, 其对齐字节数是结构体最大成员字节数, 结构体的总大小是对齐字节数的整数倍

        struct bit_field
        {
            uint8_t a : 4; /* 独占一个 uint8_t */
            uint8_t b : 5; /* 4+5 > 8, 从新的存储单元开始存放*/
            uint8_t : 3;   /* 空域, 5+3 = 8, 这个位域和前一个位域刚好填满一个存储单元*/
            uint32_t c : 3; /* 独占一个 uint32_t */
        };

        sizeof(struct bit_field) --> 4 byte
		
### "#"常见的用法

	#  				把符号转换成字符串常量
	## 				把两个符号拼成一个变量
	__VA_ARGS__  	c99新增, 用于表示...参数内容
	##__VA_ARGS__  	当可变参数长度为0时, 会自动去除前面不必要的","
