use nom::branch::alt;
use nom::bytes::complete::{is_not, take_till1};
use nom::combinator::{map, opt};
use nom::sequence::{pair, separated_pair};
use nom::IResult;

use crate::{
    color::Color,
    parse::{nom_char, skip_useless, Parser},
    serialize::ToCss,
    types::{Image, Length, Percentage, Position},
};

#[derive(Debug, PartialEq)]
pub enum Property {
    {%- for info in struct_infos -%}
        {{ pascal(text=info.name) }}({{ pascal(text=info.name) }}),
    {% endfor %}
}

impl Parser for Property {
    fn parse(i: &str) -> IResult<&str, Self> {
        let (i, i0) = is_not(";}")(i)?;
        let (_, (name, value)) = separated_pair(
            skip_useless(take_till1(|c: char| !c.is_alphanumeric() && c != '-')),
            skip_useless(nom_char(':')),
            skip_useless(take_till1(|c: char| c == ';')),
        )(i0)?;
        let (_, property) = match name {
            {%- for info in struct_infos -%}
                "{{ kebab(text=info.name) }}" => map(
                        {{ pascal(text=info.name) }}::parse,
                        |{{ snake(text=info.name) }}| Self::{{ pascal(text=info.name) }}({{ snake(text=info.name) }})
                    )(value),
            {% endfor %}
            _ => panic!("解析属性失败, property name: {}", name),
        }?;
        Ok((i, property))
    }
}

impl ToCss for Property {
    fn to_css<W>(&self, dest: &mut W) -> core::fmt::Result
    where
        W: core::fmt::Write,
    {
        match self {
            {%- for info in struct_infos -%}
                Self::{{ pascal(text=info.name) }}({{ snake(text=info.name) }}) => {
                    dest.write_str("{{ kebab(text=info.name) }}: ")?;
                    {{ snake(text=info.name) }}.to_css(dest)?;
                    dest.write_char(';')
                },
            {% endfor %}
        }
    }
}

{% for info in struct_infos %}
    pub fn {{ snake(text=info.name) }}(i: &str) -> Option<{{ pascal(text=info.name) }}> {
        let (_, v) = opt({{ pascal(text=info.name) }}::parse)(i).unwrap_or_default();
        v
    }
{% endfor %}

{% for info in struct_infos %}

    {% set name = pascal(text=info.name) %}

    {%- if info.struct_type == "enum" -%}
        #[derive(Debug, PartialEq)]
        pub enum {{ name }} {
            {% for member in info.member_list -%}
                {{ pascal(text=member) }}({{ pascal(text=member) }}),
            {% endfor %}
        }
    {% endif %}
    {%- if info.struct_type == "struct" -%}
        #[derive(Debug, Default, PartialEq)]
        pub struct {{ name }} {
            {% for member in info.member_list -%}
                pub {{ snake(text=member) }}: {{ pascal(text=member) }},
            {% endfor %}
        }
    {% endif %}

    impl Parser for {{ name }} {
        fn parse(i: &str) -> IResult<&str, Self> {
            {%- if info.struct_type == "struct" -%}
                let mut v = Self::default();
                let (i, _) = {{info.parser}}(i)?;
                Ok((i, v))
            {%- endif -%}
            {%- if info.struct_type == "enum" -%}
                {{info.parser}}(i)
            {% endif %}
        }
    }

    impl ToCss for {{ name }} {
        fn to_css<W>(&self, dest: &mut W) -> core::fmt::Result
        where
            W: core::fmt::Write,
        {
            {%- if info.struct_type == "enum" -%}
                match self {
                    {%- for member in info.member_list -%}
                        Self::{{ pascal(text=member) }}(v) => v.to_css(dest),
                    {% endfor %}
                }
            {% endif %}
            {%- if info.struct_type == "struct" -%}
                {%- for member in info.member_list -%}
                    self.{{ snake(text=member) }}.to_css(dest)?;
                    {%- if not loop.last -%}
                        dest.write_char(' ')?;
                    {% endif %}
                {% endfor %}
                Ok(())
            {% endif %}
        }
    }
{% endfor %}
